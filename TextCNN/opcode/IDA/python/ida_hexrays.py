# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
IDA Plugin SDK API wrapper: hexrays
"""


from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ida_hexrays', [dirname(__file__)])
        except ImportError:
            import _ida_hexrays
            return _ida_hexrays
        if fp is not None:
            try:
                _mod = imp.load_module('_ida_hexrays', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _ida_hexrays = swig_import_helper()
    del swig_import_helper
else:
    import _ida_hexrays
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


import ida_idaapi

import sys
_BC695 = sys.modules["__main__"].IDAPYTHON_COMPAT_695_API

if _BC695:






    def bc695redef(func):
        ida_idaapi._BC695.replace_fun(func)
        return func

import ida_typeinf
import ida_idp

def _kludge_use_TPopupMenu(*args):
  """
  _kludge_use_TPopupMenu(m)
  """
  return _ida_hexrays._kludge_use_TPopupMenu(*args)
class user_numforms_t(object):
    """
    Proxy of C++ std::map<(operand_locator_t,number_format_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> number_format_t
        """
        return _ida_hexrays.user_numforms_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_numforms_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_numforms_t
        """
        this = _ida_hexrays.new_user_numforms_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_numforms_t
    __del__ = lambda self : None;
user_numforms_t_swigregister = _ida_hexrays.user_numforms_t_swigregister
user_numforms_t_swigregister(user_numforms_t)

class lvar_mapping_t(object):
    """
    Proxy of C++ std::map<(lvar_locator_t,lvar_locator_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> lvar_locator_t
        """
        return _ida_hexrays.lvar_mapping_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.lvar_mapping_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> lvar_mapping_t
        """
        this = _ida_hexrays.new_lvar_mapping_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvar_mapping_t
    __del__ = lambda self : None;
lvar_mapping_t_swigregister = _ida_hexrays.lvar_mapping_t_swigregister
lvar_mapping_t_swigregister(lvar_mapping_t)

class hexwarns_t(object):
    """
    Proxy of C++ qvector<(hexwarn_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> hexwarns_t
        __init__(self, x) -> hexwarns_t
        """
        this = _ida_hexrays.new_hexwarns_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_hexwarns_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.hexwarns_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.hexwarns_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.hexwarns_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.hexwarns_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.hexwarns_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.hexwarns_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=hexwarn_t())
        """
        return _ida_hexrays.hexwarns_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.hexwarns_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.hexwarns_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.hexwarns_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.hexwarns_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.hexwarns_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.hexwarns_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.hexwarns_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> hexwarn_t
        begin(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> hexwarn_t
        end(self) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> hexwarn_t
        erase(self, first, last) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> hexwarn_t
        find(self, x) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.hexwarns_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.hexwarns_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.hexwarns_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.hexwarns_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> hexwarn_t
        """
        return _ida_hexrays.hexwarns_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.hexwarns_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

hexwarns_t_swigregister = _ida_hexrays.hexwarns_t_swigregister
hexwarns_t_swigregister(hexwarns_t)

class ctree_items_t(object):
    """
    Proxy of C++ qvector<(p.citem_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> ctree_items_t
        __init__(self, x) -> ctree_items_t
        """
        this = _ida_hexrays.new_ctree_items_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ctree_items_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> citem_t *&
        """
        return _ida_hexrays.ctree_items_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.ctree_items_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.ctree_items_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.ctree_items_t_empty(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.ctree_items_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.ctree_items_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.ctree_items_t_resize(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.ctree_items_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.ctree_items_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.ctree_items_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.ctree_items_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> citem_t **
        """
        return _ida_hexrays.ctree_items_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.ctree_items_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ctree_items_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ctree_items_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qvector< citem_t * >::iterator
        begin(self) -> qvector< citem_t * >::const_iterator
        """
        return _ida_hexrays.ctree_items_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qvector< citem_t * >::iterator
        end(self) -> qvector< citem_t * >::const_iterator
        """
        return _ida_hexrays.ctree_items_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> qvector< citem_t * >::iterator
        """
        return _ida_hexrays.ctree_items_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> qvector< citem_t * >::iterator
        erase(self, first, last) -> qvector< citem_t * >::iterator
        """
        return _ida_hexrays.ctree_items_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> qvector< citem_t * >::iterator
        find(self, x) -> qvector< citem_t * >::const_iterator
        """
        return _ida_hexrays.ctree_items_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.ctree_items_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.ctree_items_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.ctree_items_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.ctree_items_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> citem_t
        """
        return _ida_hexrays.ctree_items_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.ctree_items_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

    def at(self, *args):
        """
        at(self, n) -> citem_t
        """
        return _ida_hexrays.ctree_items_t_at(self, *args)

ctree_items_t_swigregister = _ida_hexrays.ctree_items_t_swigregister
ctree_items_t_swigregister(ctree_items_t)

class user_labels_t(object):
    """
    Proxy of C++ std::map<(int,qstring)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> _qstring< char > &
        """
        return _ida_hexrays.user_labels_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_labels_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_labels_t
        """
        this = _ida_hexrays.new_user_labels_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_labels_t
    __del__ = lambda self : None;
user_labels_t_swigregister = _ida_hexrays.user_labels_t_swigregister
user_labels_t_swigregister(user_labels_t)

class user_cmts_t(object):
    """
    Proxy of C++ std::map<(treeloc_t,citem_cmt_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> citem_cmt_t
        """
        return _ida_hexrays.user_cmts_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_cmts_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_cmts_t
        """
        this = _ida_hexrays.new_user_cmts_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_cmts_t
    __del__ = lambda self : None;
user_cmts_t_swigregister = _ida_hexrays.user_cmts_t_swigregister
user_cmts_t_swigregister(user_cmts_t)

class user_iflags_t(object):
    """
    Proxy of C++ std::map<(citem_locator_t,int32)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> int &
        """
        return _ida_hexrays.user_iflags_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_iflags_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_iflags_t
        """
        this = _ida_hexrays.new_user_iflags_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_iflags_t
    __del__ = lambda self : None;
user_iflags_t_swigregister = _ida_hexrays.user_iflags_t_swigregister
user_iflags_t_swigregister(user_iflags_t)

class user_unions_t(object):
    """
    Proxy of C++ std::map<(ea_t,intvec_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> qvector< int > &
        """
        return _ida_hexrays.user_unions_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.user_unions_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_unions_t
        """
        this = _ida_hexrays.new_user_unions_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_unions_t
    __del__ = lambda self : None;
user_unions_t_swigregister = _ida_hexrays.user_unions_t_swigregister
user_unions_t_swigregister(user_unions_t)

class cinsnptrvec_t(object):
    """
    Proxy of C++ qvector<(p.cinsn_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> cinsnptrvec_t
        __init__(self, x) -> cinsnptrvec_t
        """
        this = _ida_hexrays.new_cinsnptrvec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cinsnptrvec_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> cinsn_t *&
        """
        return _ida_hexrays.cinsnptrvec_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.cinsnptrvec_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.cinsnptrvec_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t_empty(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.cinsnptrvec_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.cinsnptrvec_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.cinsnptrvec_t_resize(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.cinsnptrvec_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.cinsnptrvec_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.cinsnptrvec_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.cinsnptrvec_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> cinsn_t **
        """
        return _ida_hexrays.cinsnptrvec_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.cinsnptrvec_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qvector< cinsn_t * >::iterator
        begin(self) -> qvector< cinsn_t * >::const_iterator
        """
        return _ida_hexrays.cinsnptrvec_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qvector< cinsn_t * >::iterator
        end(self) -> qvector< cinsn_t * >::const_iterator
        """
        return _ida_hexrays.cinsnptrvec_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> qvector< cinsn_t * >::iterator
        """
        return _ida_hexrays.cinsnptrvec_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> qvector< cinsn_t * >::iterator
        erase(self, first, last) -> qvector< cinsn_t * >::iterator
        """
        return _ida_hexrays.cinsnptrvec_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> qvector< cinsn_t * >::iterator
        find(self, x) -> qvector< cinsn_t * >::const_iterator
        """
        return _ida_hexrays.cinsnptrvec_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.cinsnptrvec_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.cinsnptrvec_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> cinsn_t
        """
        return _ida_hexrays.cinsnptrvec_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.cinsnptrvec_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

    def at(self, *args):
        """
        at(self, n) -> cinsn_t
        """
        return _ida_hexrays.cinsnptrvec_t_at(self, *args)

cinsnptrvec_t_swigregister = _ida_hexrays.cinsnptrvec_t_swigregister
cinsnptrvec_t_swigregister(cinsnptrvec_t)

class eamap_t(object):
    """
    Proxy of C++ std::map<(ea_t,cinsnptrvec_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> cinsnptrvec_t
        """
        return _ida_hexrays.eamap_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.eamap_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> eamap_t
        """
        this = _ida_hexrays.new_eamap_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_eamap_t
    __del__ = lambda self : None;
eamap_t_swigregister = _ida_hexrays.eamap_t_swigregister
eamap_t_swigregister(eamap_t)

class boundaries_t(object):
    """
    Proxy of C++ std::map<(p.cinsn_t,rangeset_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def at(self, *args):
        """
        at(self, _Keyval) -> rangeset_t
        """
        return _ida_hexrays.boundaries_t_at(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.boundaries_t_size(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> boundaries_t
        """
        this = _ida_hexrays.new_boundaries_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_boundaries_t
    __del__ = lambda self : None;
boundaries_t_swigregister = _ida_hexrays.boundaries_t_swigregister
boundaries_t_swigregister(boundaries_t)


def user_iflags_second(*args):
  """
  user_iflags_second(p) -> int32 const &


  Get reference to the current map value.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_second(*args)
class cfuncptr_t(object):
    """
    Proxy of C++ qrefcnt_t<(cfunc_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, p) -> cfuncptr_t
        __init__(self, r) -> cfuncptr_t
        """
        this = _ida_hexrays.new_cfuncptr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def reset(self, *args):
        """
        reset(self)
        """
        return _ida_hexrays.cfuncptr_t_reset(self, *args)

    def __deref__(self, *args):
        """
        __deref__(self) -> cfunc_t
        """
        return _ida_hexrays.cfuncptr_t___deref__(self, *args)

    def __ref__(self, *args):
        """
        __ref__(self) -> cfunc_t
        """
        return _ida_hexrays.cfuncptr_t___ref__(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cfuncptr_t
    __del__ = lambda self : None;
    entry_ea = _swig_property(_ida_hexrays.cfuncptr_t_entry_ea_get, _ida_hexrays.cfuncptr_t_entry_ea_set)
    mba = _swig_property(_ida_hexrays.cfuncptr_t_mba_get, _ida_hexrays.cfuncptr_t_mba_set)
    body = _swig_property(_ida_hexrays.cfuncptr_t_body_get, _ida_hexrays.cfuncptr_t_body_set)
    argidx = _swig_property(_ida_hexrays.cfuncptr_t_argidx_get)
    maturity = _swig_property(_ida_hexrays.cfuncptr_t_maturity_get, _ida_hexrays.cfuncptr_t_maturity_set)
    user_labels = _swig_property(_ida_hexrays.cfuncptr_t_user_labels_get, _ida_hexrays.cfuncptr_t_user_labels_set)
    user_cmts = _swig_property(_ida_hexrays.cfuncptr_t_user_cmts_get, _ida_hexrays.cfuncptr_t_user_cmts_set)
    numforms = _swig_property(_ida_hexrays.cfuncptr_t_numforms_get, _ida_hexrays.cfuncptr_t_numforms_set)
    user_iflags = _swig_property(_ida_hexrays.cfuncptr_t_user_iflags_get, _ida_hexrays.cfuncptr_t_user_iflags_set)
    user_unions = _swig_property(_ida_hexrays.cfuncptr_t_user_unions_get, _ida_hexrays.cfuncptr_t_user_unions_set)
    refcnt = _swig_property(_ida_hexrays.cfuncptr_t_refcnt_get, _ida_hexrays.cfuncptr_t_refcnt_set)
    statebits = _swig_property(_ida_hexrays.cfuncptr_t_statebits_get, _ida_hexrays.cfuncptr_t_statebits_set)
    hdrlines = _swig_property(_ida_hexrays.cfuncptr_t_hdrlines_get, _ida_hexrays.cfuncptr_t_hdrlines_set)
    treeitems = _swig_property(_ida_hexrays.cfuncptr_t_treeitems_get, _ida_hexrays.cfuncptr_t_treeitems_set)
    def release(self, *args):
        """
        release(self)
        """
        return _ida_hexrays.cfuncptr_t_release(self, *args)

    def build_c_tree(self, *args):
        """
        build_c_tree(self)
        """
        return _ida_hexrays.cfuncptr_t_build_c_tree(self, *args)

    def verify(self, *args):
        """
        verify(self, aul, even_without_debugger)
        """
        return _ida_hexrays.cfuncptr_t_verify(self, *args)

    def print_dcl(self, *args):
        """
        print_dcl(self)
        """
        return _ida_hexrays.cfuncptr_t_print_dcl(self, *args)

    def print_func(self, *args):
        """
        print_func(self, vp)
        """
        return _ida_hexrays.cfuncptr_t_print_func(self, *args)

    def get_func_type(self, *args):
        """
        get_func_type(self, type) -> bool
        """
        return _ida_hexrays.cfuncptr_t_get_func_type(self, *args)

    def get_lvars(self, *args):
        """
        get_lvars(self) -> lvars_t
        """
        return _ida_hexrays.cfuncptr_t_get_lvars(self, *args)

    def get_stkoff_delta(self, *args):
        """
        get_stkoff_delta(self) -> sval_t
        """
        return _ida_hexrays.cfuncptr_t_get_stkoff_delta(self, *args)

    def find_label(self, *args):
        """
        find_label(self, label) -> citem_t
        """
        return _ida_hexrays.cfuncptr_t_find_label(self, *args)

    def remove_unused_labels(self, *args):
        """
        remove_unused_labels(self)
        """
        return _ida_hexrays.cfuncptr_t_remove_unused_labels(self, *args)

    def get_user_cmt(self, *args):
        """
        get_user_cmt(self, loc, rt) -> char const *
        """
        return _ida_hexrays.cfuncptr_t_get_user_cmt(self, *args)

    def set_user_cmt(self, *args):
        """
        set_user_cmt(self, loc, cmt)
        """
        return _ida_hexrays.cfuncptr_t_set_user_cmt(self, *args)

    def get_user_iflags(self, *args):
        """
        get_user_iflags(self, loc) -> int32
        """
        return _ida_hexrays.cfuncptr_t_get_user_iflags(self, *args)

    def set_user_iflags(self, *args):
        """
        set_user_iflags(self, loc, iflags)
        """
        return _ida_hexrays.cfuncptr_t_set_user_iflags(self, *args)

    def has_orphan_cmts(self, *args):
        """
        has_orphan_cmts(self) -> bool
        """
        return _ida_hexrays.cfuncptr_t_has_orphan_cmts(self, *args)

    def del_orphan_cmts(self, *args):
        """
        del_orphan_cmts(self) -> int
        """
        return _ida_hexrays.cfuncptr_t_del_orphan_cmts(self, *args)

    def get_user_union_selection(self, *args):
        """
        get_user_union_selection(self, ea, path) -> bool
        """
        return _ida_hexrays.cfuncptr_t_get_user_union_selection(self, *args)

    def set_user_union_selection(self, *args):
        """
        set_user_union_selection(self, ea, path)
        """
        return _ida_hexrays.cfuncptr_t_set_user_union_selection(self, *args)

    def save_user_labels(self, *args):
        """
        save_user_labels(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_labels(self, *args)

    def save_user_cmts(self, *args):
        """
        save_user_cmts(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_cmts(self, *args)

    def save_user_numforms(self, *args):
        """
        save_user_numforms(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_numforms(self, *args)

    def save_user_iflags(self, *args):
        """
        save_user_iflags(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_iflags(self, *args)

    def save_user_unions(self, *args):
        """
        save_user_unions(self)
        """
        return _ida_hexrays.cfuncptr_t_save_user_unions(self, *args)

    def get_line_item(self, *args):
        """
        get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
        """
        return _ida_hexrays.cfuncptr_t_get_line_item(self, *args)

    def get_warnings(self, *args):
        """
        get_warnings(self) -> hexwarns_t
        """
        return _ida_hexrays.cfuncptr_t_get_warnings(self, *args)

    def get_eamap(self, *args):
        """
        get_eamap(self) -> eamap_t
        """
        return _ida_hexrays.cfuncptr_t_get_eamap(self, *args)

    def get_boundaries(self, *args):
        """
        get_boundaries(self) -> boundaries_t
        """
        return _ida_hexrays.cfuncptr_t_get_boundaries(self, *args)

    def get_pseudocode(self, *args):
        """
        get_pseudocode(self) -> strvec_t const &
        """
        return _ida_hexrays.cfuncptr_t_get_pseudocode(self, *args)

    def gather_derefs(self, *args):
        """
        gather_derefs(self, ci, udm=None) -> bool
        """
        return _ida_hexrays.cfuncptr_t_gather_derefs(self, *args)

    def find_item_coords(self, *args):
        """
        find_item_coords(self, item, px, py) -> bool
        find_item_coords(self, item) -> PyObject *
        """
        return _ida_hexrays.cfuncptr_t_find_item_coords(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> qstring
        """
        return _ida_hexrays.cfuncptr_t___str__(self, *args)

cfuncptr_t_swigregister = _ida_hexrays.cfuncptr_t_swigregister
cfuncptr_t_swigregister(cfuncptr_t)

class qvector_history_t(object):
    """
    Proxy of C++ qvector<(history_item_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_history_t
        __init__(self, x) -> qvector_history_t
        """
        this = _ida_hexrays.new_qvector_history_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_history_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_history_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_history_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_history_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_history_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_history_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_history_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=history_item_t())
        """
        return _ida_hexrays.qvector_history_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_history_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_history_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_history_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_history_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_history_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_history_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_history_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> history_item_t
        begin(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> history_item_t
        end(self) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> history_item_t
        erase(self, first, last) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> history_item_t
        find(self, x) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_history_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_history_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_history_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_history_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> history_item_t
        """
        return _ida_hexrays.qvector_history_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_history_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_history_t_swigregister = _ida_hexrays.qvector_history_t_swigregister
qvector_history_t_swigregister(qvector_history_t)

class history_t(qvector_history_t):
    """
    Proxy of C++ qstack<(history_item_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def pop(self, *args):
        """
        pop(self) -> history_item_t
        """
        return _ida_hexrays.history_t_pop(self, *args)

    def top(self, *args):
        """
        top(self) -> history_item_t
        top(self) -> history_item_t
        """
        return _ida_hexrays.history_t_top(self, *args)

    def push(self, *args):
        """
        push(self, v)
        """
        return _ida_hexrays.history_t_push(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> history_t
        """
        this = _ida_hexrays.new_history_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_history_t
    __del__ = lambda self : None;
history_t_swigregister = _ida_hexrays.history_t_swigregister
history_t_swigregister(history_t)

class qlist_cinsn_t_iterator(object):
    """
    Proxy of C++ qlist_cinsn_t_iterator class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cur = _swig_property(_ida_hexrays.qlist_cinsn_t_iterator_cur_get)
    def next(self, *args):
        """
        next(self)
        """
        return _ida_hexrays.qlist_cinsn_t_iterator_next(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t_iterator___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t_iterator___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> qlist_cinsn_t_iterator
        """
        this = _ida_hexrays.new_qlist_cinsn_t_iterator(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qlist_cinsn_t_iterator
    __del__ = lambda self : None;
qlist_cinsn_t_iterator_swigregister = _ida_hexrays.qlist_cinsn_t_iterator_swigregister
qlist_cinsn_t_iterator_swigregister(qlist_cinsn_t_iterator)

class qvector_lvar_t(object):
    """
    Proxy of C++ qvector<(lvar_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_lvar_t
        __init__(self, x) -> qvector_lvar_t
        """
        this = _ida_hexrays.new_qvector_lvar_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_lvar_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_lvar_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_lvar_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_lvar_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_lvar_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_lvar_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_lvar_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=lvar_t())
        """
        return _ida_hexrays.qvector_lvar_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_lvar_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_lvar_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_lvar_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_lvar_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_lvar_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_lvar_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_lvar_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> lvar_t
        begin(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> lvar_t
        end(self) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> lvar_t
        erase(self, first, last) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> lvar_t
        find(self, x) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_lvar_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_lvar_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_lvar_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_lvar_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> lvar_t
        """
        return _ida_hexrays.qvector_lvar_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_lvar_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_lvar_t_swigregister = _ida_hexrays.qvector_lvar_t_swigregister
qvector_lvar_t_swigregister(qvector_lvar_t)

class qlist_cinsn_t(object):
    """
    Proxy of C++ qlist<(cinsn_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qlist_cinsn_t
        __init__(self, x) -> qlist_cinsn_t
        """
        this = _ida_hexrays.new_qlist_cinsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qlist_cinsn_t
    __del__ = lambda self : None;
    def swap(self, *args):
        """
        swap(self, x)
        """
        return _ida_hexrays.qlist_cinsn_t_swap(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t_empty(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qlist_cinsn_t_size(self, *args)

    def front(self, *args):
        """
        front(self) -> cinsn_t
        front(self) -> cinsn_t
        """
        return _ida_hexrays.qlist_cinsn_t_front(self, *args)

    def back(self, *args):
        """
        back(self) -> cinsn_t
        back(self) -> cinsn_t
        """
        return _ida_hexrays.qlist_cinsn_t_back(self, *args)

    def rbegin(self, *args):
        """
        rbegin(self) -> qlist< cinsn_t >::reverse_iterator
        rbegin(self) -> qlist< cinsn_t >::const_reverse_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_rbegin(self, *args)

    def rend(self, *args):
        """
        rend(self) -> qlist< cinsn_t >::reverse_iterator
        rend(self) -> qlist< cinsn_t >::const_reverse_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_rend(self, *args)

    def push_front(self, *args):
        """
        push_front(self, x)
        """
        return _ida_hexrays.qlist_cinsn_t_push_front(self, *args)

    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> cinsn_t
        """
        return _ida_hexrays.qlist_cinsn_t_push_back(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qlist_cinsn_t_clear(self, *args)

    def pop_front(self, *args):
        """
        pop_front(self)
        """
        return _ida_hexrays.qlist_cinsn_t_pop_front(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qlist_cinsn_t_pop_back(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, x) -> bool
        """
        return _ida_hexrays.qlist_cinsn_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> qlist_cinsn_t_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> qlist_cinsn_t_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, p, x) -> qlist< cinsn_t >::iterator
        insert(self, p) -> cinsn_t
        insert(self, p, x) -> qlist_cinsn_t_iterator
        """
        return _ida_hexrays.qlist_cinsn_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, p) -> qlist< cinsn_t >::iterator
        erase(self, p1, p2)
        erase(self, p)
        """
        return _ida_hexrays.qlist_cinsn_t_erase(self, *args)

qlist_cinsn_t_swigregister = _ida_hexrays.qlist_cinsn_t_swigregister
qlist_cinsn_t_swigregister(qlist_cinsn_t)

class qvector_carg_t(object):
    """
    Proxy of C++ qvector<(carg_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_carg_t
        __init__(self, x) -> qvector_carg_t
        """
        this = _ida_hexrays.new_qvector_carg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_carg_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_carg_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_carg_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_carg_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_carg_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_carg_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_carg_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=carg_t())
        """
        return _ida_hexrays.qvector_carg_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_carg_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_carg_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_carg_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_carg_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_carg_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_carg_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_carg_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> carg_t
        begin(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> carg_t
        end(self) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> carg_t
        erase(self, first, last) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> carg_t
        find(self, x) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_carg_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_carg_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_carg_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_carg_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> carg_t
        """
        return _ida_hexrays.qvector_carg_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_carg_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_carg_t_swigregister = _ida_hexrays.qvector_carg_t_swigregister
qvector_carg_t_swigregister(qvector_carg_t)

class qvector_ccase_t(object):
    """
    Proxy of C++ qvector<(ccase_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> qvector_ccase_t
        __init__(self, x) -> qvector_ccase_t
        """
        this = _ida_hexrays.new_qvector_ccase_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_qvector_ccase_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.qvector_ccase_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.qvector_ccase_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.qvector_ccase_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.qvector_ccase_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.qvector_ccase_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.qvector_ccase_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=ccase_t())
        """
        return _ida_hexrays.qvector_ccase_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.qvector_ccase_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.qvector_ccase_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.qvector_ccase_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.qvector_ccase_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.qvector_ccase_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.qvector_ccase_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.qvector_ccase_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> ccase_t
        begin(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> ccase_t
        end(self) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> ccase_t
        erase(self, first, last) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> ccase_t
        find(self, x) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.qvector_ccase_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.qvector_ccase_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.qvector_ccase_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.qvector_ccase_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> ccase_t
        """
        return _ida_hexrays.qvector_ccase_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.qvector_ccase_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

qvector_ccase_t_swigregister = _ida_hexrays.qvector_ccase_t_swigregister
qvector_ccase_t_swigregister(qvector_ccase_t)

class lvar_saved_infos_t(object):
    """
    Proxy of C++ qvector<(lvar_saved_info_t)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> lvar_saved_infos_t
        __init__(self, x) -> lvar_saved_infos_t
        """
        this = _ida_hexrays.new_lvar_saved_infos_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvar_saved_infos_t
    __del__ = lambda self : None;
    def push_back(self, *args):
        """
        push_back(self, x)
        push_back(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_push_back(self, *args)

    def pop_back(self, *args):
        """
        pop_back(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_pop_back(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.lvar_saved_infos_t_size(self, *args)

    def empty(self, *args):
        """
        empty(self) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t_empty(self, *args)

    def at(self, *args):
        """
        at(self, _idx) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_at(self, *args)

    def qclear(self, *args):
        """
        qclear(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_qclear(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_clear(self, *args)

    def resize(self, *args):
        """
        resize(self, _newsize, x)
        resize(self, _newsize)
        """
        return _ida_hexrays.lvar_saved_infos_t_resize(self, *args)

    def grow(self, *args):
        """
        grow(self, x=lvar_saved_info_t())
        """
        return _ida_hexrays.lvar_saved_infos_t_grow(self, *args)

    def capacity(self, *args):
        """
        capacity(self) -> size_t
        """
        return _ida_hexrays.lvar_saved_infos_t_capacity(self, *args)

    def reserve(self, *args):
        """
        reserve(self, cnt)
        """
        return _ida_hexrays.lvar_saved_infos_t_reserve(self, *args)

    def truncate(self, *args):
        """
        truncate(self)
        """
        return _ida_hexrays.lvar_saved_infos_t_truncate(self, *args)

    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.lvar_saved_infos_t_swap(self, *args)

    def extract(self, *args):
        """
        extract(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_extract(self, *args)

    def inject(self, *args):
        """
        inject(self, s, len)
        """
        return _ida_hexrays.lvar_saved_infos_t_inject(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t___ne__(self, *args)

    def begin(self, *args):
        """
        begin(self) -> lvar_saved_info_t
        begin(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_begin(self, *args)

    def end(self, *args):
        """
        end(self) -> lvar_saved_info_t
        end(self) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_end(self, *args)

    def insert(self, *args):
        """
        insert(self, it, x) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_insert(self, *args)

    def erase(self, *args):
        """
        erase(self, it) -> lvar_saved_info_t
        erase(self, first, last) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_erase(self, *args)

    def find(self, *args):
        """
        find(self, x) -> lvar_saved_info_t
        find(self, x) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t_find(self, *args)

    def has(self, *args):
        """
        has(self, x) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t_has(self, *args)

    def add_unique(self, *args):
        """
        add_unique(self, x) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t_add_unique(self, *args)

    def _del(self, *args):
        """
        _del(self, x) -> bool
        """
        return _ida_hexrays.lvar_saved_infos_t__del(self, *args)

    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.lvar_saved_infos_t___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_saved_infos_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.lvar_saved_infos_t___setitem__(self, *args)

    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

lvar_saved_infos_t_swigregister = _ida_hexrays.lvar_saved_infos_t_swigregister
lvar_saved_infos_t_swigregister(lvar_saved_infos_t)


def qswap(*args):
  """
  qswap(a, b)
  """
  return _ida_hexrays.qswap(*args)
class fnum_array(object):
    """
    Proxy of C++ wrapped_array_t<(uint16,6)> class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = _swig_property(_ida_hexrays.fnum_array_data_get)
    def __init__(self, *args):
        """
        __init__(self, data) -> fnum_array
        """
        this = _ida_hexrays.new_fnum_array(*args)
        try: self.this.append(this)
        except: self.this = this
    def __len__(self, *args):
        """
        __len__(self) -> size_t
        """
        return _ida_hexrays.fnum_array___len__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(self, i) -> unsigned short const &
        """
        return _ida_hexrays.fnum_array___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(self, i, v)
        """
        return _ida_hexrays.fnum_array___setitem__(self, *args)

    __iter__ = ida_idaapi._bounded_getitem_iterator

    __swig_destroy__ = _ida_hexrays.delete_fnum_array
    __del__ = lambda self : None;
fnum_array_swigregister = _ida_hexrays.fnum_array_swigregister
fnum_array_swigregister(fnum_array)


def debug_hexrays_ctree(*args):
  """
  debug_hexrays_ctree(msg)
  """
  return _ida_hexrays.debug_hexrays_ctree(*args)

def init_hexrays_plugin(*args):
  """
  init_hexrays_plugin(flags=0) -> bool


  Initialize your plugin for hex-rays decompiler. This function must be
  called before calling any other decompiler function. It initializes
  the pointer to the dispatcher.
  
  @param flags: reserved, must be 0 (C++: int)
  @return: true if the decompiler exists and the dispatcher pointer is
           ready to use.
  """
  return _ida_hexrays.init_hexrays_plugin(*args)

def _decompile(*args):
  """
  _decompile(pfn, hf) -> cfuncptr_t
  """
  return _ida_hexrays._decompile(*args)

def decompile_many(*args):
  """
  decompile_many(outfile, funcaddrs, flags) -> bool


  Batch decompilation. Decompile all or the specified functions
  
  @param outfile: name of the output file (C++: const char *)
  @param funcaddrs: list of functions to decompile. If NULL or empty,
                    then decompile all nonlib functions (C++: eavec_t
                    *)
  @param flags: Batch decompilation bits (C++: int)
  @return: true if no internal error occurred and the user has not
           cancelled decompilation
  """
  return _ida_hexrays.decompile_many(*args)

def get_widget_vdui(*args):
  """
  get_widget_vdui(f) -> vdui_t


  Get the 'vdui_t' instance associated to the TWidget
  
  @param f: pointer to window (C++: TWidget *)
  @return: a  vdui_t  *, or NULL
  """
  return _ida_hexrays.get_widget_vdui(*args)

def boundaries_find(*args):
  """
  boundaries_find(map, key) -> boundaries_iterator_t


  Find the specified key in boundaries_t.
  
  
  @param map (C++: const boundaries_t *)
  @param key (C++: const  cinsn_t  *&)
  """
  return _ida_hexrays.boundaries_find(*args)

def boundaries_insert(*args):
  """
  boundaries_insert(map, key, val) -> boundaries_iterator_t


  Insert new ( 'cinsn_t' *, 'rangeset_t' ) pair into boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  @param key (C++: const  cinsn_t  *&)
  @param val (C++: const  rangeset_t  &)
  """
  return _ida_hexrays.boundaries_insert(*args)

def term_hexrays_plugin(*args):
  """
  term_hexrays_plugin()


  Stop working with hex-rays decompiler.
  """
  return _ida_hexrays.term_hexrays_plugin(*args)
class Hexrays_Hooks(object):
    """
    Proxy of C++ Hexrays_Hooks class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> Hexrays_Hooks
        """
        if self.__class__ == Hexrays_Hooks:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_Hexrays_Hooks(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_Hexrays_Hooks
    __del__ = lambda self : None;
    def hook(self, *args):
        """
        hook(self) -> bool
        """
        return _ida_hexrays.Hexrays_Hooks_hook(self, *args)

    def unhook(self, *args):
        """
        unhook(self) -> bool
        """
        return _ida_hexrays.Hexrays_Hooks_unhook(self, *args)

    def flowchart(self, *args):
        """
        flowchart(self, fc) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_flowchart(self, *args)

    def stkpnts(self, *args):
        """
        stkpnts(self, mba, stkpnts) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_stkpnts(self, *args)

    def prolog(self, *args):
        """
        prolog(self, mba, fc, reachable_blocks) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_prolog(self, *args)

    def microcode(self, *args):
        """
        microcode(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_microcode(self, *args)

    def preoptimized(self, *args):
        """
        preoptimized(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_preoptimized(self, *args)

    def locopt(self, *args):
        """
        locopt(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_locopt(self, *args)

    def prealloc(self, *args):
        """
        prealloc(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_prealloc(self, *args)

    def glbopt(self, *args):
        """
        glbopt(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_glbopt(self, *args)

    def structural(self, *args):
        """
        structural(self, ct) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_structural(self, *args)

    def maturity(self, *args):
        """
        maturity(self, cfunc, new_maturity) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_maturity(self, *args)

    def interr(self, *args):
        """
        interr(self, errcode) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_interr(self, *args)

    def combine(self, *args):
        """
        combine(self, blk, insn) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_combine(self, *args)

    def print_func(self, *args):
        """
        print_func(self, cfunc, vp) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_print_func(self, *args)

    def func_printed(self, *args):
        """
        func_printed(self, cfunc) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_func_printed(self, *args)

    def resolve_stkaddrs(self, *args):
        """
        resolve_stkaddrs(self, mba) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_resolve_stkaddrs(self, *args)

    def open_pseudocode(self, *args):
        """
        open_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_open_pseudocode(self, *args)

    def switch_pseudocode(self, *args):
        """
        switch_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_switch_pseudocode(self, *args)

    def refresh_pseudocode(self, *args):
        """
        refresh_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_refresh_pseudocode(self, *args)

    def close_pseudocode(self, *args):
        """
        close_pseudocode(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_close_pseudocode(self, *args)

    def keyboard(self, *args):
        """
        keyboard(self, vu, key_code, shift_state) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_keyboard(self, *args)

    def right_click(self, *args):
        """
        right_click(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_right_click(self, *args)

    def double_click(self, *args):
        """
        double_click(self, vu, shift_state) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_double_click(self, *args)

    def curpos(self, *args):
        """
        curpos(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_curpos(self, *args)

    def create_hint(self, *args):
        """
        create_hint(self, vu) -> PyObject *
        """
        return _ida_hexrays.Hexrays_Hooks_create_hint(self, *args)

    def text_ready(self, *args):
        """
        text_ready(self, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_text_ready(self, *args)

    def populating_popup(self, *args):
        """
        populating_popup(self, widget, popup_handle, vu) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_populating_popup(self, *args)

    def lvar_name_changed(self, *args):
        """
        lvar_name_changed(self, vu, v, name, is_user_name) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_name_changed(self, *args)

    def lvar_type_changed(self, *args):
        """
        lvar_type_changed(self, vu, v, tinfo) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_type_changed(self, *args)

    def lvar_cmt_changed(self, *args):
        """
        lvar_cmt_changed(self, vu, v, cmt) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_cmt_changed(self, *args)

    def lvar_mapping_changed(self, *args):
        """
        lvar_mapping_changed(self, vu, _from, to) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_lvar_mapping_changed(self, *args)

    def cmt_changed(self, *args):
        """
        cmt_changed(self, cfunc, loc, cmt) -> int
        """
        return _ida_hexrays.Hexrays_Hooks_cmt_changed(self, *args)

    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_Hexrays_Hooks(self)
        return weakref_proxy(self)
Hexrays_Hooks_swigregister = _ida_hexrays.Hexrays_Hooks_swigregister
Hexrays_Hooks_swigregister(Hexrays_Hooks)

MAX_SUPPORTED_STACK_SIZE = _ida_hexrays.MAX_SUPPORTED_STACK_SIZE

def hexrays_alloc(*args):
  """
  hexrays_alloc(size) -> void *
  """
  return _ida_hexrays.hexrays_alloc(*args)

def hexrays_free(*args):
  """
  hexrays_free(ptr)
  """
  return _ida_hexrays.hexrays_free(*args)
MAX_VLR_SIZE = _ida_hexrays.MAX_VLR_SIZE
CMP_NZ = _ida_hexrays.CMP_NZ
CMP_Z = _ida_hexrays.CMP_Z
CMP_AE = _ida_hexrays.CMP_AE
CMP_B = _ida_hexrays.CMP_B
CMP_A = _ida_hexrays.CMP_A
CMP_BE = _ida_hexrays.CMP_BE
CMP_GT = _ida_hexrays.CMP_GT
CMP_GE = _ida_hexrays.CMP_GE
CMP_LT = _ida_hexrays.CMP_LT
CMP_LE = _ida_hexrays.CMP_LE
NO_ACCESS = _ida_hexrays.NO_ACCESS
WRITE_ACCESS = _ida_hexrays.WRITE_ACCESS
READ_ACCESS = _ida_hexrays.READ_ACCESS
RW_ACCESS = _ida_hexrays.RW_ACCESS
MERR_OK = _ida_hexrays.MERR_OK
MERR_BLOCK = _ida_hexrays.MERR_BLOCK
MERR_INTERR = _ida_hexrays.MERR_INTERR
MERR_INSN = _ida_hexrays.MERR_INSN
MERR_MEM = _ida_hexrays.MERR_MEM
MERR_BADBLK = _ida_hexrays.MERR_BADBLK
MERR_BADSP = _ida_hexrays.MERR_BADSP
MERR_PROLOG = _ida_hexrays.MERR_PROLOG
MERR_SWITCH = _ida_hexrays.MERR_SWITCH
MERR_EXCEPTION = _ida_hexrays.MERR_EXCEPTION
MERR_HUGESTACK = _ida_hexrays.MERR_HUGESTACK
MERR_LVARS = _ida_hexrays.MERR_LVARS
MERR_BITNESS = _ida_hexrays.MERR_BITNESS
MERR_BADCALL = _ida_hexrays.MERR_BADCALL
MERR_BADFRAME = _ida_hexrays.MERR_BADFRAME
MERR_UNKTYPE = _ida_hexrays.MERR_UNKTYPE
MERR_BADIDB = _ida_hexrays.MERR_BADIDB
MERR_SIZEOF = _ida_hexrays.MERR_SIZEOF
MERR_REDO = _ida_hexrays.MERR_REDO
MERR_CANCELED = _ida_hexrays.MERR_CANCELED
MERR_RECDEPTH = _ida_hexrays.MERR_RECDEPTH
MERR_OVERLAP = _ida_hexrays.MERR_OVERLAP
MERR_PARTINIT = _ida_hexrays.MERR_PARTINIT
MERR_COMPLEX = _ida_hexrays.MERR_COMPLEX
MERR_LICENSE = _ida_hexrays.MERR_LICENSE
MERR_ONLY32 = _ida_hexrays.MERR_ONLY32
MERR_ONLY64 = _ida_hexrays.MERR_ONLY64
MERR_BUSY = _ida_hexrays.MERR_BUSY
MERR_FARPTR = _ida_hexrays.MERR_FARPTR
MERR_EXTERN = _ida_hexrays.MERR_EXTERN
MERR_FUNCSIZE = _ida_hexrays.MERR_FUNCSIZE
MERR_BADRANGES = _ida_hexrays.MERR_BADRANGES
MERR_STOP = _ida_hexrays.MERR_STOP
MERR_MAX_ERR = _ida_hexrays.MERR_MAX_ERR
MERR_LOOP = _ida_hexrays.MERR_LOOP

def get_merror_desc(*args):
  """
  get_merror_desc(code, mba) -> ea_t


  Get textual description of an error code
  
  @param code: Microcode error codes (C++: merror_t)
  @param mba: the microcode array (C++: mbl_array_t  *)
  @return: the error address
  """
  return _ida_hexrays.get_merror_desc(*args)
class operand_locator_t(object):
    """
    Proxy of C++ operand_locator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.operand_locator_t_ea_get, _ida_hexrays.operand_locator_t_ea_set)
    opnum = _swig_property(_ida_hexrays.operand_locator_t_opnum_get, _ida_hexrays.operand_locator_t_opnum_set)
    def __init__(self, *args):
        """
        __init__(self, _ea, _opnum) -> operand_locator_t
        """
        this = _ida_hexrays.new_operand_locator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.operand_locator_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.operand_locator_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_operand_locator_t
    __del__ = lambda self : None;
operand_locator_t_swigregister = _ida_hexrays.operand_locator_t_swigregister
operand_locator_t_swigregister(operand_locator_t)
cvar = _ida_hexrays.cvar
MAX_VALUE = cvar.MAX_VALUE
MAX_SVALUE = cvar.MAX_SVALUE
MIN_SVALUE = cvar.MIN_SVALUE
MUST_ACCESS = cvar.MUST_ACCESS
MAY_ACCESS = cvar.MAY_ACCESS
MAYMUST_ACCESS_MASK = cvar.MAYMUST_ACCESS_MASK
ONE_ACCESS_TYPE = cvar.ONE_ACCESS_TYPE
INCLUDE_SPOILED_REGS = cvar.INCLUDE_SPOILED_REGS
EXCLUDE_PASS_REGS = cvar.EXCLUDE_PASS_REGS
FULL_XDSU = cvar.FULL_XDSU
WITH_ASSERTS = cvar.WITH_ASSERTS
EXCLUDE_VOLATILE = cvar.EXCLUDE_VOLATILE
INCLUDE_UNUSED_SRC = cvar.INCLUDE_UNUSED_SRC
INCLUDE_DEAD_RETREGS = cvar.INCLUDE_DEAD_RETREGS
INCLUDE_RESTRICTED = cvar.INCLUDE_RESTRICTED
mr_none = cvar.mr_none
mr_cf = cvar.mr_cf
mr_zf = cvar.mr_zf
mr_sf = cvar.mr_sf
mr_of = cvar.mr_of
mr_pf = cvar.mr_pf
cc_count = cvar.cc_count
mr_cc = cvar.mr_cc
mr_first = cvar.mr_first

class number_format_t(object):
    """
    Proxy of C++ number_format_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    flags = _swig_property(_ida_hexrays.number_format_t_flags_get, _ida_hexrays.number_format_t_flags_set)
    opnum = _swig_property(_ida_hexrays.number_format_t_opnum_get, _ida_hexrays.number_format_t_opnum_set)
    props = _swig_property(_ida_hexrays.number_format_t_props_get, _ida_hexrays.number_format_t_props_set)
    serial = _swig_property(_ida_hexrays.number_format_t_serial_get, _ida_hexrays.number_format_t_serial_set)
    org_nbytes = _swig_property(_ida_hexrays.number_format_t_org_nbytes_get, _ida_hexrays.number_format_t_org_nbytes_set)
    type_name = _swig_property(_ida_hexrays.number_format_t_type_name_get, _ida_hexrays.number_format_t_type_name_set)
    def __init__(self, *args):
        """
        __init__(self, _opnum=0) -> number_format_t
        """
        this = _ida_hexrays.new_number_format_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_radix(self, *args):
        """
        get_radix(self) -> int
        """
        return _ida_hexrays.number_format_t_get_radix(self, *args)

    def is_fixed(self, *args):
        """
        is_fixed(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_fixed(self, *args)

    def is_hex(self, *args):
        """
        is_hex(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_hex(self, *args)

    def is_dec(self, *args):
        """
        is_dec(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_dec(self, *args)

    def is_oct(self, *args):
        """
        is_oct(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_oct(self, *args)

    def is_enum(self, *args):
        """
        is_enum(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_enum(self, *args)

    def is_char(self, *args):
        """
        is_char(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_char(self, *args)

    def is_stroff(self, *args):
        """
        is_stroff(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_stroff(self, *args)

    def is_numop(self, *args):
        """
        is_numop(self) -> bool
        """
        return _ida_hexrays.number_format_t_is_numop(self, *args)

    def needs_to_be_inverted(self, *args):
        """
        needs_to_be_inverted(self) -> bool
        """
        return _ida_hexrays.number_format_t_needs_to_be_inverted(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_number_format_t
    __del__ = lambda self : None;
number_format_t_swigregister = _ida_hexrays.number_format_t_swigregister
number_format_t_swigregister(number_format_t)
NF_FIXED = _ida_hexrays.NF_FIXED
"""
number format has been defined by the user
"""
NF_NEGDONE = _ida_hexrays.NF_NEGDONE
"""
temporary internal bit: negation has been performed
"""
NF_BINVDONE = _ida_hexrays.NF_BINVDONE
"""
temporary internal bit: inverting bits is done
"""
NF_NEGATE = _ida_hexrays.NF_NEGATE
"""
The user asked to negate the constant.
"""
NF_BITNOT = _ida_hexrays.NF_BITNOT
"""
The user asked to invert bits of the constant.
"""
NF_STROFF = _ida_hexrays.NF_STROFF
"""
internal bit: used as stroff, valid iff 'is_stroff()'
"""

class vd_printer_t(object):
    """
    Proxy of C++ vd_printer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hdrlines = _swig_property(_ida_hexrays.vd_printer_t_hdrlines_get, _ida_hexrays.vd_printer_t_hdrlines_set)
    def _print(self, *args):
        """
        _print(self, indent, format) -> int
        """
        return _ida_hexrays.vd_printer_t__print(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> vd_printer_t
        """
        this = _ida_hexrays.new_vd_printer_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_vd_printer_t
    __del__ = lambda self : None;
vd_printer_t_swigregister = _ida_hexrays.vd_printer_t_swigregister
vd_printer_t_swigregister(vd_printer_t)

class vc_printer_t(vd_printer_t):
    """
    Proxy of C++ vc_printer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    func = _swig_property(_ida_hexrays.vc_printer_t_func_get, _ida_hexrays.vc_printer_t_func_set)
    lastchar = _swig_property(_ida_hexrays.vc_printer_t_lastchar_get, _ida_hexrays.vc_printer_t_lastchar_set)
    def __init__(self, *args):
        """
        __init__(self, f) -> vc_printer_t
        """
        this = _ida_hexrays.new_vc_printer_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def oneliner(self, *args):
        """
        oneliner(self) -> bool
        """
        return _ida_hexrays.vc_printer_t_oneliner(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vc_printer_t
    __del__ = lambda self : None;
vc_printer_t_swigregister = _ida_hexrays.vc_printer_t_swigregister
vc_printer_t_swigregister(vc_printer_t)

class qstring_printer_t(vc_printer_t):
    """
    Proxy of C++ qstring_printer_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    with_tags = _swig_property(_ida_hexrays.qstring_printer_t_with_tags_get, _ida_hexrays.qstring_printer_t_with_tags_set)
    s = _swig_property(_ida_hexrays.qstring_printer_t_s_get, _ida_hexrays.qstring_printer_t_s_set)
    def _print(self, *args):
        """
        _print(self, indent, format) -> int
        """
        return _ida_hexrays.qstring_printer_t__print(self, *args)

    def __init__(self, *args):
        """
        __init__(self, f, tags) -> qstring_printer_t
        """
        this = _ida_hexrays.new_qstring_printer_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_s(self, *args):
        """
        get_s(self) -> qstring
        """
        return _ida_hexrays.qstring_printer_t_get_s(self, *args)

    s = property(lambda self: self.get_s())

qstring_printer_t_swigregister = _ida_hexrays.qstring_printer_t_swigregister
qstring_printer_t_swigregister(qstring_printer_t)


def is_type_correct(*args):
  """
  is_type_correct(ptr) -> bool


  Verify a type string.
  
  @param ptr (C++: const  type_t  *)
  @return: true if type string is correct
  """
  return _ida_hexrays.is_type_correct(*args)

def is_small_struni(*args):
  """
  is_small_struni(tif) -> bool


  Is a small structure or union?
  
  @param tif (C++: const  tinfo_t  &)
  @return: true if the type is a small UDT (user defined type). Small
           UDTs fit into a register (or pair or registers) as a rule.
  """
  return _ida_hexrays.is_small_struni(*args)

def is_nonbool_type(*args):
  """
  is_nonbool_type(type) -> bool


  Is definitely a non-boolean type?
  
  @param type (C++: const  tinfo_t  &)
  @return: true if the type is a non-boolean type (non bool and well
           defined)
  """
  return _ida_hexrays.is_nonbool_type(*args)

def is_bool_type(*args):
  """
  is_bool_type(type) -> bool


  Is a boolean type?
  
  @param type (C++: const  tinfo_t  &)
  @return: true if the type is a boolean type
  """
  return _ida_hexrays.is_bool_type(*args)

def is_ptr_or_array(*args):
  """
  is_ptr_or_array(t) -> bool


  Is a pointer or array type?
  
  
  @param t (C++: type_t)
  """
  return _ida_hexrays.is_ptr_or_array(*args)

def is_paf(*args):
  """
  is_paf(t) -> bool


  Is a pointer, array, or function type?
  
  
  @param t (C++: type_t)
  """
  return _ida_hexrays.is_paf(*args)

def is_inplace_def(*args):
  """
  is_inplace_def(type) -> bool


  Is struct/union/enum definition (not declaration)?
  
  
  @param type (C++: const  tinfo_t  &)
  """
  return _ida_hexrays.is_inplace_def(*args)

def partial_type_num(*args):
  """
  partial_type_num(type) -> int


  Calculate number of partial subtypes.
  
  @param type (C++: const  tinfo_t  &)
  @return: number of partial subtypes. The bigger is this number, the
           uglier is the type.
  """
  return _ida_hexrays.partial_type_num(*args)

def get_float_type(*args):
  """
  get_float_type(width) -> tinfo_t


  Get a type of a floating point value with the specified width
  
  @param width: width of the desired type (C++: int)
  @return: type info object
  """
  return _ida_hexrays.get_float_type(*args)

def get_int_type_by_width_and_sign(*args):
  """
  get_int_type_by_width_and_sign(srcwidth, sign) -> tinfo_t


  Create a type info by width and sign. Returns a simple type (examples:
  int, short) with the given width and sign.
  
  @param srcwidth: size of the type in bytes (C++: int)
  @param sign: sign of the type (C++: type_sign_t)
  """
  return _ida_hexrays.get_int_type_by_width_and_sign(*args)

def get_unk_type(*args):
  """
  get_unk_type(size) -> tinfo_t


  Create a partial type info by width. Returns a partially defined type
  (examples: _DWORD, _BYTE) with the given width.
  
  @param size: size of the type in bytes (C++: int)
  """
  return _ida_hexrays.get_unk_type(*args)

def dummy_ptrtype(*args):
  """
  dummy_ptrtype(ptrsize, isfp) -> tinfo_t


  Generate a dummy pointer type
  
  @param ptrsize: size of pointed object (C++: int)
  @param isfp: is floating point object? (C++: bool)
  """
  return _ida_hexrays.dummy_ptrtype(*args)

def get_member_type(*args):
  """
  get_member_type(mptr, type) -> bool


  Get type of a structure field. This function performs validity checks
  of the field type. Wrong types are rejected.
  
  @param mptr: structure field (C++: const  member_t  *)
  @param type: pointer to the variable where the type is returned. This
               parameter can be NULL. (C++: tinfo_t  *)
  @return: false if failed
  """
  return _ida_hexrays.get_member_type(*args)

def make_pointer(*args):
  """
  make_pointer(type) -> tinfo_t


  Create a pointer type. This function performs the following
  conversion: "type" -> "type*"
  
  @param type: object type. (C++: const  tinfo_t  &)
  @return: "type*". for example, if 'char' is passed as the argument,
  """
  return _ida_hexrays.make_pointer(*args)

def create_typedef(*args):
  """
    create_typedef(name) -> tinfo_t
    create_typedef(n) -> tinfo_t


  Create a reference to a named type.
  
  @param name: type name (C++: const char *)
  @return: type which refers to the specified name. For example, if name
           is "DWORD", the type info which refers to "DWORD" is created.
    """
  return _ida_hexrays.create_typedef(*args)
GUESSED_NONE = _ida_hexrays.GUESSED_NONE
GUESSED_WEAK = _ida_hexrays.GUESSED_WEAK
GUESSED_FUNC = _ida_hexrays.GUESSED_FUNC
GUESSED_DATA = _ida_hexrays.GUESSED_DATA
TS_NOELL = _ida_hexrays.TS_NOELL
TS_SHRINK = _ida_hexrays.TS_SHRINK
TS_DONTREF = _ida_hexrays.TS_DONTREF
TS_MASK = _ida_hexrays.TS_MASK

def get_type(*args):
  """
  get_type(id, tif, guess) -> bool


  Get a global type. Global types are types of addressable objects and
  struct/union/enum types
  
  @param id: address or id of the object (C++: uval_t)
  @param tif: buffer for the answer (C++: tinfo_t  *)
  @param guess: what kind of types to consider (C++: type_source_t)
  @return: success
  """
  return _ida_hexrays.get_type(*args)

def set_type(*args):
  """
  set_type(id, tif, source, force=False) -> bool


  Set a global type.
  
  @param id: address or id of the object (C++: uval_t)
  @param tif: new type info (C++: const  tinfo_t  &)
  @param source: where the type comes from (C++: type_source_t)
  @param force: true means to set the type as is, false means to merge
                the new type with the possibly existing old type info.
                (C++: bool)
  @return: success
  """
  return _ida_hexrays.set_type(*args)
class vdloc_t(ida_typeinf.argloc_t):
    """
    Proxy of C++ vdloc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def reg1(self, *args):
        """
        reg1(self) -> int
        """
        return _ida_hexrays.vdloc_t_reg1(self, *args)

    def _set_reg1(self, *args):
        """
        _set_reg1(self, r1)
        """
        return _ida_hexrays.vdloc_t__set_reg1(self, *args)

    def set_reg1(self, *args):
        """
        set_reg1(self, r1)
        """
        return _ida_hexrays.vdloc_t_set_reg1(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.vdloc_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.vdloc_t_compare(self, *args)

    def is_aliasable(self, *args):
        """
        is_aliasable(self, mb, size) -> bool
        """
        return _ida_hexrays.vdloc_t_is_aliasable(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> vdloc_t
        """
        this = _ida_hexrays.new_vdloc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_vdloc_t
    __del__ = lambda self : None;
vdloc_t_swigregister = _ida_hexrays.vdloc_t_swigregister
vdloc_t_swigregister(vdloc_t)


def print_vdloc(*args):
  """
  print_vdloc(loc, nbytes)


  Print vdloc. Since vdloc does not always carry the size info, we pass
  it as NBYTES..
  
  @param loc (C++: const  vdloc_t  &)
  @param nbytes (C++: int)
  """
  return _ida_hexrays.print_vdloc(*args)

def arglocs_overlap(*args):
  """
  arglocs_overlap(loc1, w1, loc2, w2) -> bool


  Do two arglocs overlap?
  
  
  @param loc1 (C++: const  vdloc_t  &)
  @param w1 (C++: size_t)
  @param loc2 (C++: const  vdloc_t  &)
  @param w2 (C++: size_t)
  """
  return _ida_hexrays.arglocs_overlap(*args)
class lvar_locator_t(object):
    """
    Proxy of C++ lvar_locator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    location = _swig_property(_ida_hexrays.lvar_locator_t_location_get, _ida_hexrays.lvar_locator_t_location_set)
    defea = _swig_property(_ida_hexrays.lvar_locator_t_defea_get, _ida_hexrays.lvar_locator_t_defea_set)
    def __init__(self, *args):
        """
        __init__(self) -> lvar_locator_t
        __init__(self, loc, ea) -> lvar_locator_t
        """
        this = _ida_hexrays.new_lvar_locator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_stkoff(self, *args):
        """
        get_stkoff(self) -> sval_t
        """
        return _ida_hexrays.lvar_locator_t_get_stkoff(self, *args)

    def is_reg1(self, *args):
        """
        is_reg1(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_reg1(self, *args)

    def is_reg2(self, *args):
        """
        is_reg2(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_reg2(self, *args)

    def is_reg_var(self, *args):
        """
        is_reg_var(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_reg_var(self, *args)

    def is_stk_var(self, *args):
        """
        is_stk_var(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_stk_var(self, *args)

    def is_scattered(self, *args):
        """
        is_scattered(self) -> bool
        """
        return _ida_hexrays.lvar_locator_t_is_scattered(self, *args)

    def get_reg1(self, *args):
        """
        get_reg1(self) -> mreg_t
        """
        return _ida_hexrays.lvar_locator_t_get_reg1(self, *args)

    def get_reg2(self, *args):
        """
        get_reg2(self) -> mreg_t
        """
        return _ida_hexrays.lvar_locator_t_get_reg2(self, *args)

    def get_scattered(self, *args):
        """
        get_scattered(self) -> scattered_aloc_t
        get_scattered(self) -> scattered_aloc_t
        """
        return _ida_hexrays.lvar_locator_t_get_scattered(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.lvar_locator_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.lvar_locator_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_locator_t
    __del__ = lambda self : None;
lvar_locator_t_swigregister = _ida_hexrays.lvar_locator_t_swigregister
lvar_locator_t_swigregister(lvar_locator_t)

class lvar_t(lvar_locator_t):
    """
    Proxy of C++ lvar_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    name = _swig_property(_ida_hexrays.lvar_t_name_get, _ida_hexrays.lvar_t_name_set)
    cmt = _swig_property(_ida_hexrays.lvar_t_cmt_get, _ida_hexrays.lvar_t_cmt_set)
    tif = _swig_property(_ida_hexrays.lvar_t_tif_get, _ida_hexrays.lvar_t_tif_set)
    width = _swig_property(_ida_hexrays.lvar_t_width_get, _ida_hexrays.lvar_t_width_set)
    defblk = _swig_property(_ida_hexrays.lvar_t_defblk_get, _ida_hexrays.lvar_t_defblk_set)
    divisor = _swig_property(_ida_hexrays.lvar_t_divisor_get, _ida_hexrays.lvar_t_divisor_set)
    def used(self, *args):
        """
        used(self) -> bool
        """
        return _ida_hexrays.lvar_t_used(self, *args)

    def typed(self, *args):
        """
        typed(self) -> bool
        """
        return _ida_hexrays.lvar_t_typed(self, *args)

    def mreg_done(self, *args):
        """
        mreg_done(self) -> bool
        """
        return _ida_hexrays.lvar_t_mreg_done(self, *args)

    def has_nice_name(self, *args):
        """
        has_nice_name(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_nice_name(self, *args)

    def is_unknown_width(self, *args):
        """
        is_unknown_width(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_unknown_width(self, *args)

    def has_user_info(self, *args):
        """
        has_user_info(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_user_info(self, *args)

    def has_user_name(self, *args):
        """
        has_user_name(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_user_name(self, *args)

    def has_user_type(self, *args):
        """
        has_user_type(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_user_type(self, *args)

    def is_result_var(self, *args):
        """
        is_result_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_result_var(self, *args)

    def is_arg_var(self, *args):
        """
        is_arg_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_arg_var(self, *args)

    def is_fake_var(self, *args):
        """
        is_fake_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_fake_var(self, *args)

    def is_overlapped_var(self, *args):
        """
        is_overlapped_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_overlapped_var(self, *args)

    def is_floating_var(self, *args):
        """
        is_floating_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_floating_var(self, *args)

    def is_spoiled_var(self, *args):
        """
        is_spoiled_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_spoiled_var(self, *args)

    def is_noptr_var(self, *args):
        """
        is_noptr_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_noptr_var(self, *args)

    def is_mapdst_var(self, *args):
        """
        is_mapdst_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_mapdst_var(self, *args)

    def is_thisarg(self, *args):
        """
        is_thisarg(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_thisarg(self, *args)

    def is_forced_var(self, *args):
        """
        is_forced_var(self) -> bool
        """
        return _ida_hexrays.lvar_t_is_forced_var(self, *args)

    def has_regname(self, *args):
        """
        has_regname(self) -> bool
        """
        return _ida_hexrays.lvar_t_has_regname(self, *args)

    def set_used(self, *args):
        """
        set_used(self)
        """
        return _ida_hexrays.lvar_t_set_used(self, *args)

    def clear_used(self, *args):
        """
        clear_used(self)
        """
        return _ida_hexrays.lvar_t_clear_used(self, *args)

    def set_typed(self, *args):
        """
        set_typed(self)
        """
        return _ida_hexrays.lvar_t_set_typed(self, *args)

    def set_non_typed(self, *args):
        """
        set_non_typed(self)
        """
        return _ida_hexrays.lvar_t_set_non_typed(self, *args)

    def clr_user_info(self, *args):
        """
        clr_user_info(self)
        """
        return _ida_hexrays.lvar_t_clr_user_info(self, *args)

    def set_user_name(self, *args):
        """
        set_user_name(self)
        """
        return _ida_hexrays.lvar_t_set_user_name(self, *args)

    def set_user_type(self, *args):
        """
        set_user_type(self)
        """
        return _ida_hexrays.lvar_t_set_user_type(self, *args)

    def clr_user_type(self, *args):
        """
        clr_user_type(self)
        """
        return _ida_hexrays.lvar_t_clr_user_type(self, *args)

    def clr_user_name(self, *args):
        """
        clr_user_name(self)
        """
        return _ida_hexrays.lvar_t_clr_user_name(self, *args)

    def set_mreg_done(self, *args):
        """
        set_mreg_done(self)
        """
        return _ida_hexrays.lvar_t_set_mreg_done(self, *args)

    def clr_mreg_done(self, *args):
        """
        clr_mreg_done(self)
        """
        return _ida_hexrays.lvar_t_clr_mreg_done(self, *args)

    def set_unknown_width(self, *args):
        """
        set_unknown_width(self)
        """
        return _ida_hexrays.lvar_t_set_unknown_width(self, *args)

    def clr_unknown_width(self, *args):
        """
        clr_unknown_width(self)
        """
        return _ida_hexrays.lvar_t_clr_unknown_width(self, *args)

    def set_arg_var(self, *args):
        """
        set_arg_var(self)
        """
        return _ida_hexrays.lvar_t_set_arg_var(self, *args)

    def clr_arg_var(self, *args):
        """
        clr_arg_var(self)
        """
        return _ida_hexrays.lvar_t_clr_arg_var(self, *args)

    def set_fake_var(self, *args):
        """
        set_fake_var(self)
        """
        return _ida_hexrays.lvar_t_set_fake_var(self, *args)

    def clr_fake_var(self, *args):
        """
        clr_fake_var(self)
        """
        return _ida_hexrays.lvar_t_clr_fake_var(self, *args)

    def set_overlapped_var(self, *args):
        """
        set_overlapped_var(self)
        """
        return _ida_hexrays.lvar_t_set_overlapped_var(self, *args)

    def clr_overlapped_var(self, *args):
        """
        clr_overlapped_var(self)
        """
        return _ida_hexrays.lvar_t_clr_overlapped_var(self, *args)

    def set_floating_var(self, *args):
        """
        set_floating_var(self)
        """
        return _ida_hexrays.lvar_t_set_floating_var(self, *args)

    def clr_floating_var(self, *args):
        """
        clr_floating_var(self)
        """
        return _ida_hexrays.lvar_t_clr_floating_var(self, *args)

    def set_spoiled_var(self, *args):
        """
        set_spoiled_var(self)
        """
        return _ida_hexrays.lvar_t_set_spoiled_var(self, *args)

    def clr_spoiled_var(self, *args):
        """
        clr_spoiled_var(self)
        """
        return _ida_hexrays.lvar_t_clr_spoiled_var(self, *args)

    def set_mapdst_var(self, *args):
        """
        set_mapdst_var(self)
        """
        return _ida_hexrays.lvar_t_set_mapdst_var(self, *args)

    def clr_mapdst_var(self, *args):
        """
        clr_mapdst_var(self)
        """
        return _ida_hexrays.lvar_t_clr_mapdst_var(self, *args)

    def set_noptr_var(self, *args):
        """
        set_noptr_var(self)
        """
        return _ida_hexrays.lvar_t_set_noptr_var(self, *args)

    def clr_noptr_var(self, *args):
        """
        clr_noptr_var(self)
        """
        return _ida_hexrays.lvar_t_clr_noptr_var(self, *args)

    def set_thisarg(self, *args):
        """
        set_thisarg(self)
        """
        return _ida_hexrays.lvar_t_set_thisarg(self, *args)

    def clr_thisarg(self, *args):
        """
        clr_thisarg(self)
        """
        return _ida_hexrays.lvar_t_clr_thisarg(self, *args)

    def set_forced_var(self, *args):
        """
        set_forced_var(self)
        """
        return _ida_hexrays.lvar_t_set_forced_var(self, *args)

    def clr_forced_var(self, *args):
        """
        clr_forced_var(self)
        """
        return _ida_hexrays.lvar_t_clr_forced_var(self, *args)

    def has_common(self, *args):
        """
        has_common(self, v) -> bool
        """
        return _ida_hexrays.lvar_t_has_common(self, *args)

    def has_common_bit(self, *args):
        """
        has_common_bit(self, loc, width2) -> bool
        """
        return _ida_hexrays.lvar_t_has_common_bit(self, *args)

    def type(self, *args):
        """
        type(self) -> tinfo_t
        type(self) -> tinfo_t
        """
        return _ida_hexrays.lvar_t_type(self, *args)

    def accepts_type(self, *args):
        """
        accepts_type(self, t, may_change_thisarg=False) -> bool
        """
        return _ida_hexrays.lvar_t_accepts_type(self, *args)

    def set_lvar_type(self, *args):
        """
        set_lvar_type(self, t, may_fail=False) -> bool
        """
        return _ida_hexrays.lvar_t_set_lvar_type(self, *args)

    def set_final_lvar_type(self, *args):
        """
        set_final_lvar_type(self, t)
        """
        return _ida_hexrays.lvar_t_set_final_lvar_type(self, *args)

    def set_width(self, *args):
        """
        set_width(self, w, svw_flags=0) -> bool
        """
        return _ida_hexrays.lvar_t_set_width(self, *args)

    def append_list(self, *args):
        """
        append_list(self, lst, pad_if_scattered=False)
        """
        return _ida_hexrays.lvar_t_append_list(self, *args)

    def is_aliasable(self, *args):
        """
        is_aliasable(self, mba) -> bool
        """
        return _ida_hexrays.lvar_t_is_aliasable(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_t
    __del__ = lambda self : None;
lvar_t_swigregister = _ida_hexrays.lvar_t_swigregister
lvar_t_swigregister(lvar_t)
SVW_INT = _ida_hexrays.SVW_INT
SVW_FLOAT = _ida_hexrays.SVW_FLOAT
SVW_SOFT = _ida_hexrays.SVW_SOFT

class lvars_t(qvector_lvar_t):
    """
    Proxy of C++ lvars_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def find_input_lvar(self, *args):
        """
        find_input_lvar(self, argloc, _size) -> int
        """
        return _ida_hexrays.lvars_t_find_input_lvar(self, *args)

    def find_stkvar(self, *args):
        """
        find_stkvar(self, spoff, width) -> int
        """
        return _ida_hexrays.lvars_t_find_stkvar(self, *args)

    def find(self, *args):
        """
        find(self, ll) -> lvar_t
        """
        return _ida_hexrays.lvars_t_find(self, *args)

    def find_lvar(self, *args):
        """
        find_lvar(self, location, width, defblk=-1) -> int
        """
        return _ida_hexrays.lvars_t_find_lvar(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> lvars_t
        """
        this = _ida_hexrays.new_lvars_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvars_t
    __del__ = lambda self : None;
lvars_t_swigregister = _ida_hexrays.lvars_t_swigregister
lvars_t_swigregister(lvars_t)

class lvar_saved_info_t(object):
    """
    Proxy of C++ lvar_saved_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ll = _swig_property(_ida_hexrays.lvar_saved_info_t_ll_get, _ida_hexrays.lvar_saved_info_t_ll_set)
    name = _swig_property(_ida_hexrays.lvar_saved_info_t_name_get, _ida_hexrays.lvar_saved_info_t_name_set)
    type = _swig_property(_ida_hexrays.lvar_saved_info_t_type_get, _ida_hexrays.lvar_saved_info_t_type_set)
    cmt = _swig_property(_ida_hexrays.lvar_saved_info_t_cmt_get, _ida_hexrays.lvar_saved_info_t_cmt_set)
    size = _swig_property(_ida_hexrays.lvar_saved_info_t_size_get, _ida_hexrays.lvar_saved_info_t_size_set)
    flags = _swig_property(_ida_hexrays.lvar_saved_info_t_flags_get, _ida_hexrays.lvar_saved_info_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> lvar_saved_info_t
        """
        this = _ida_hexrays.new_lvar_saved_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def has_info(self, *args):
        """
        has_info(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_has_info(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t___ne__(self, *args)

    def is_kept(self, *args):
        """
        is_kept(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_is_kept(self, *args)

    def clear_keep(self, *args):
        """
        clear_keep(self)
        """
        return _ida_hexrays.lvar_saved_info_t_clear_keep(self, *args)

    def set_keep(self, *args):
        """
        set_keep(self)
        """
        return _ida_hexrays.lvar_saved_info_t_set_keep(self, *args)

    def is_forced_lvar(self, *args):
        """
        is_forced_lvar(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_is_forced_lvar(self, *args)

    def set_forced_lvar(self, *args):
        """
        set_forced_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_set_forced_lvar(self, *args)

    def clr_forced_lvar(self, *args):
        """
        clr_forced_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_clr_forced_lvar(self, *args)

    def is_noptr_lvar(self, *args):
        """
        is_noptr_lvar(self) -> bool
        """
        return _ida_hexrays.lvar_saved_info_t_is_noptr_lvar(self, *args)

    def set_noptr_lvar(self, *args):
        """
        set_noptr_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_set_noptr_lvar(self, *args)

    def clr_noptr_lvar(self, *args):
        """
        clr_noptr_lvar(self)
        """
        return _ida_hexrays.lvar_saved_info_t_clr_noptr_lvar(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_saved_info_t
    __del__ = lambda self : None;
lvar_saved_info_t_swigregister = _ida_hexrays.lvar_saved_info_t_swigregister
lvar_saved_info_t_swigregister(lvar_saved_info_t)
LVINF_KEEP = _ida_hexrays.LVINF_KEEP
"""
preserve saved user settings regardless of vars for example, if a var
loses all its user-defined attributes or even gets destroyed, keep its
'lvar_saved_info_t' . this is used for ephemeral variables that get
destroyed by macro recognition.
"""
LVINF_FORCE = _ida_hexrays.LVINF_FORCE
"""
force allocation of a new variable. forces the decompiler to create a
new variable at ll.defea
"""
LVINF_NOPTR = _ida_hexrays.LVINF_NOPTR
"""
variable type should not be a pointer
"""

class lvar_uservec_t(object):
    """
    Proxy of C++ lvar_uservec_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lvvec = _swig_property(_ida_hexrays.lvar_uservec_t_lvvec_get, _ida_hexrays.lvar_uservec_t_lvvec_set)
    lmaps = _swig_property(_ida_hexrays.lvar_uservec_t_lmaps_get, _ida_hexrays.lvar_uservec_t_lmaps_set)
    stkoff_delta = _swig_property(_ida_hexrays.lvar_uservec_t_stkoff_delta_get, _ida_hexrays.lvar_uservec_t_stkoff_delta_set)
    ulv_flags = _swig_property(_ida_hexrays.lvar_uservec_t_ulv_flags_get, _ida_hexrays.lvar_uservec_t_ulv_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> lvar_uservec_t
        """
        this = _ida_hexrays.new_lvar_uservec_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.lvar_uservec_t_swap(self, *args)

    def find_info(self, *args):
        """
        find_info(self, vloc) -> lvar_saved_info_t
        """
        return _ida_hexrays.lvar_uservec_t_find_info(self, *args)

    def keep_info(self, *args):
        """
        keep_info(self, v)
        """
        return _ida_hexrays.lvar_uservec_t_keep_info(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_lvar_uservec_t
    __del__ = lambda self : None;
lvar_uservec_t_swigregister = _ida_hexrays.lvar_uservec_t_swigregister
lvar_uservec_t_swigregister(lvar_uservec_t)
ULV_PRECISE_DEFEA = _ida_hexrays.ULV_PRECISE_DEFEA
"""
Use precise defea's for lvar locations.
"""


def restore_user_lvar_settings(*args):
  """
  restore_user_lvar_settings(lvinf, func_ea) -> bool


  Restore user defined local variable settings in the database.
  
  @param lvinf: ptr to output buffer (C++: lvar_uservec_t  *)
  @param func_ea: entry address of the function (C++: ea_t)
  @return: success
  """
  return _ida_hexrays.restore_user_lvar_settings(*args)

def save_user_lvar_settings(*args):
  """
  save_user_lvar_settings(func_ea, lvinf)


  Save user defined local variable settings into the database.
  
  @param func_ea: entry address of the function (C++: ea_t)
  @param lvinf: user-specified info about local variables (C++: const
                lvar_uservec_t  &)
  """
  return _ida_hexrays.save_user_lvar_settings(*args)
class user_lvar_modifier_t(object):
    """
    Proxy of C++ user_lvar_modifier_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def modify_lvars(self, *args):
        """
        modify_lvars(self, lvinf) -> bool
        """
        return _ida_hexrays.user_lvar_modifier_t_modify_lvars(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_lvar_modifier_t
        """
        if self.__class__ == user_lvar_modifier_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_user_lvar_modifier_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_lvar_modifier_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_user_lvar_modifier_t(self)
        return weakref_proxy(self)
user_lvar_modifier_t_swigregister = _ida_hexrays.user_lvar_modifier_t_swigregister
user_lvar_modifier_t_swigregister(user_lvar_modifier_t)


def modify_user_lvars(*args):
  """
  modify_user_lvars(entry_ea, mlv) -> bool


  Modify saved local variable settings.
  
  @param entry_ea: function start address (C++: ea_t)
  @param mlv: local variable modifier (C++: user_lvar_modifier_t  &)
  @return: true if modified variables
  """
  return _ida_hexrays.modify_user_lvars(*args)
class udcall_t(object):
    """
    Proxy of C++ udcall_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    name = _swig_property(_ida_hexrays.udcall_t_name_get, _ida_hexrays.udcall_t_name_set)
    tif = _swig_property(_ida_hexrays.udcall_t_tif_get, _ida_hexrays.udcall_t_tif_set)
    def __init__(self, *args):
        """
        __init__(self) -> udcall_t
        """
        this = _ida_hexrays.new_udcall_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_udcall_t
    __del__ = lambda self : None;
udcall_t_swigregister = _ida_hexrays.udcall_t_swigregister
udcall_t_swigregister(udcall_t)


def restore_user_defined_calls(*args):
  """
  restore_user_defined_calls(udcalls, func_ea) -> bool


  Restore user defined function calls from the database.
  
  @param udcalls: ptr to output buffer (C++: udcall_map_t *)
  @param func_ea: entry address of the function (C++: ea_t)
  @return: success
  """
  return _ida_hexrays.restore_user_defined_calls(*args)

def save_user_defined_calls(*args):
  """
  save_user_defined_calls(func_ea, udcalls)


  Save user defined local function calls into the database.
  
  @param func_ea: entry address of the function (C++: ea_t)
  @param udcalls: user-specified info about user defined function calls
                  (C++: const udcall_map_t &)
  """
  return _ida_hexrays.save_user_defined_calls(*args)

def parse_user_call(*args):
  """
  parse_user_call(udc, decl, silent) -> bool


  Convert function type declaration into internal structure
  
  @param udc: - pointer to output structure (C++: udcall_t  *)
  @param decl: - function type declaration (C++: const char *)
  @param silent: - if TRUE: do not show warning in case of incorrect
                 type (C++: bool)
  @return: success
  """
  return _ida_hexrays.parse_user_call(*args)

def convert_to_user_call(*args):
  """
  convert_to_user_call(udc, cdg) -> merror_t


  try to generate user-defined call for an instruction
  
  @param udc (C++: const  udcall_t  &)
  @param cdg (C++: codegen_t  &)
  @return: Microcode error codes  code: MERR_OK - user-defined call
           generated else - error (MERR_INSN == inacceptable udc.tif)
  """
  return _ida_hexrays.convert_to_user_call(*args)
class microcode_filter_t(object):
    """
    Proxy of C++ microcode_filter_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def match(self, *args):
        """
        match(self, cdg) -> bool
        """
        return _ida_hexrays.microcode_filter_t_match(self, *args)

    def apply(self, *args):
        """
        apply(self, cdg) -> merror_t
        """
        return _ida_hexrays.microcode_filter_t_apply(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> microcode_filter_t
        """
        if self.__class__ == microcode_filter_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_microcode_filter_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_microcode_filter_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_microcode_filter_t(self)
        return weakref_proxy(self)
microcode_filter_t_swigregister = _ida_hexrays.microcode_filter_t_swigregister
microcode_filter_t_swigregister(microcode_filter_t)


def install_microcode_filter(*args):
  """
  install_microcode_filter(filter, install=True)


  register/unregister non-standard microcode generator
  
  @param filter: - microcode generator object (C++: microcode_filter_t
                 *)
  @param install: - TRUE - register the object, FALSE - unregister (C++:
                  bool)
  """
  return _ida_hexrays.install_microcode_filter(*args)
class udc_filter_t(microcode_filter_t):
    """
    Proxy of C++ udc_filter_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def match(self, *args):
        """
        match(self, cdg) -> bool
        """
        return _ida_hexrays.udc_filter_t_match(self, *args)

    def init(self, *args):
        """
        init(self, decl) -> bool
        """
        return _ida_hexrays.udc_filter_t_init(self, *args)

    def apply(self, *args):
        """
        apply(self, cdg) -> merror_t
        """
        return _ida_hexrays.udc_filter_t_apply(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> udc_filter_t
        """
        if self.__class__ == udc_filter_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_udc_filter_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_udc_filter_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_udc_filter_t(self)
        return weakref_proxy(self)
udc_filter_t_swigregister = _ida_hexrays.udc_filter_t_swigregister
udc_filter_t_swigregister(udc_filter_t)

class fnumber_t(object):
    """
    Proxy of C++ fnumber_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    fnum = _swig_property(_ida_hexrays.fnumber_t_fnum_get, _ida_hexrays.fnumber_t_fnum_set)
    nbytes = _swig_property(_ida_hexrays.fnumber_t_nbytes_get, _ida_hexrays.fnumber_t_nbytes_set)
    def dereference_uint16(self, *args):
        """
        dereference_uint16(self) -> uint16 *
        """
        return _ida_hexrays.fnumber_t_dereference_uint16(self, *args)

    def dereference_const_uint16(self, *args):
        """
        dereference_const_uint16(self) -> uint16 const *
        """
        return _ida_hexrays.fnumber_t_dereference_const_uint16(self, *args)

    def _print(self, *args):
        """
        _print(self)
        """
        return _ida_hexrays.fnumber_t__print(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.fnumber_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.fnumber_t_compare(self, *args)

    def __get_fnum(self, *args):
        """
        __get_fnum(self) -> fnum_array
        """
        return _ida_hexrays.fnumber_t___get_fnum(self, *args)

    fnum = property(__get_fnum)

    def __init__(self, *args):
        """
        __init__(self) -> fnumber_t
        """
        this = _ida_hexrays.new_fnumber_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_fnumber_t
    __del__ = lambda self : None;
fnumber_t_swigregister = _ida_hexrays.fnumber_t_swigregister
fnumber_t_swigregister(fnumber_t)
bitset_width = cvar.bitset_width
bitset_align = cvar.bitset_align
bitset_shift = cvar.bitset_shift
mop_z = cvar.mop_z
mop_r = cvar.mop_r
mop_n = cvar.mop_n
mop_str = cvar.mop_str
mop_d = cvar.mop_d
mop_S = cvar.mop_S
mop_v = cvar.mop_v
mop_b = cvar.mop_b
mop_f = cvar.mop_f
mop_l = cvar.mop_l
mop_a = cvar.mop_a
mop_h = cvar.mop_h
mop_c = cvar.mop_c
mop_fn = cvar.mop_fn
mop_p = cvar.mop_p
mop_sc = cvar.mop_sc
NOSIZE = cvar.NOSIZE

SHINS_NUMADDR = _ida_hexrays.SHINS_NUMADDR
"""
display definition addresses for numbers
"""
SHINS_VALNUM = _ida_hexrays.SHINS_VALNUM
"""
display value numbers
"""
SHINS_SHORT = _ida_hexrays.SHINS_SHORT
"""
do not display use-def chains and other attrs
"""
SHINS_LDXEA = _ida_hexrays.SHINS_LDXEA
"""
display address of ldx expressions (not used)
"""
NO_SIDEFF = _ida_hexrays.NO_SIDEFF
WITH_SIDEFF = _ida_hexrays.WITH_SIDEFF
ONLY_SIDEFF = _ida_hexrays.ONLY_SIDEFF
ANY_REGSIZE = _ida_hexrays.ANY_REGSIZE
ROLE_UNK = _ida_hexrays.ROLE_UNK
ROLE_EMPTY = _ida_hexrays.ROLE_EMPTY
ROLE_MEMSET = _ida_hexrays.ROLE_MEMSET
ROLE_MEMSET32 = _ida_hexrays.ROLE_MEMSET32
ROLE_MEMSET64 = _ida_hexrays.ROLE_MEMSET64
ROLE_MEMCPY = _ida_hexrays.ROLE_MEMCPY
ROLE_STRCPY = _ida_hexrays.ROLE_STRCPY
ROLE_STRLEN = _ida_hexrays.ROLE_STRLEN
ROLE_STRCAT = _ida_hexrays.ROLE_STRCAT
ROLE_TAIL = _ida_hexrays.ROLE_TAIL
ROLE_BUG = _ida_hexrays.ROLE_BUG
ROLE_ALLOCA = _ida_hexrays.ROLE_ALLOCA
ROLE_BSWAP = _ida_hexrays.ROLE_BSWAP
ROLE_PRESENT = _ida_hexrays.ROLE_PRESENT
ROLE_CONTAINING_RECORD = _ida_hexrays.ROLE_CONTAINING_RECORD
ROLE_FASTFAIL = _ida_hexrays.ROLE_FASTFAIL
ROLE_READFLAGS = _ida_hexrays.ROLE_READFLAGS
ROLE_IS_MUL_OK = _ida_hexrays.ROLE_IS_MUL_OK
ROLE_SATURATED_MUL = _ida_hexrays.ROLE_SATURATED_MUL
ROLE_BITTEST = _ida_hexrays.ROLE_BITTEST
ROLE_BITTESTANDSET = _ida_hexrays.ROLE_BITTESTANDSET
ROLE_BITTESTANDRESET = _ida_hexrays.ROLE_BITTESTANDRESET
ROLE_BITTESTANDCOMPLEMENT = _ida_hexrays.ROLE_BITTESTANDCOMPLEMENT
ROLE_VA_ARG = _ida_hexrays.ROLE_VA_ARG
ROLE_VA_COPY = _ida_hexrays.ROLE_VA_COPY
ROLE_VA_START = _ida_hexrays.ROLE_VA_START
ROLE_VA_END = _ida_hexrays.ROLE_VA_END
ROLE_ROL = _ida_hexrays.ROLE_ROL
ROLE_ROR = _ida_hexrays.ROLE_ROR
ROLE_CFSUB3 = _ida_hexrays.ROLE_CFSUB3
ROLE_OFSUB3 = _ida_hexrays.ROLE_OFSUB3
ROLE_ABS = _ida_hexrays.ROLE_ABS
FUNC_NAME_MEMCPY = _ida_hexrays.FUNC_NAME_MEMCPY
FUNC_NAME_MEMSET = _ida_hexrays.FUNC_NAME_MEMSET
FUNC_NAME_MEMSET32 = _ida_hexrays.FUNC_NAME_MEMSET32
FUNC_NAME_MEMSET64 = _ida_hexrays.FUNC_NAME_MEMSET64
FUNC_NAME_STRCPY = _ida_hexrays.FUNC_NAME_STRCPY
FUNC_NAME_STRLEN = _ida_hexrays.FUNC_NAME_STRLEN
FUNC_NAME_STRCAT = _ida_hexrays.FUNC_NAME_STRCAT
FUNC_NAME_TAIL = _ida_hexrays.FUNC_NAME_TAIL
FUNC_NAME_VA_ARG = _ida_hexrays.FUNC_NAME_VA_ARG
FUNC_NAME_EMPTY = _ida_hexrays.FUNC_NAME_EMPTY
FUNC_NAME_PRESENT = _ida_hexrays.FUNC_NAME_PRESENT
FUNC_NAME_CONTAINING_RECORD = _ida_hexrays.FUNC_NAME_CONTAINING_RECORD
SIZEOF_BLOCK_CHAINS = _ida_hexrays.SIZEOF_BLOCK_CHAINS
BLT_NONE = _ida_hexrays.BLT_NONE
BLT_STOP = _ida_hexrays.BLT_STOP
BLT_0WAY = _ida_hexrays.BLT_0WAY
BLT_1WAY = _ida_hexrays.BLT_1WAY
BLT_2WAY = _ida_hexrays.BLT_2WAY
BLT_NWAY = _ida_hexrays.BLT_NWAY
BLT_XTRN = _ida_hexrays.BLT_XTRN
WARN_VARARG_REGS = _ida_hexrays.WARN_VARARG_REGS
WARN_ILL_PURGED = _ida_hexrays.WARN_ILL_PURGED
WARN_ILL_FUNCTYPE = _ida_hexrays.WARN_ILL_FUNCTYPE
WARN_VARARG_TCAL = _ida_hexrays.WARN_VARARG_TCAL
WARN_VARARG_NOSTK = _ida_hexrays.WARN_VARARG_NOSTK
WARN_VARARG_MANY = _ida_hexrays.WARN_VARARG_MANY
WARN_ADDR_OUTARGS = _ida_hexrays.WARN_ADDR_OUTARGS
WARN_DEP_UNK_CALLS = _ida_hexrays.WARN_DEP_UNK_CALLS
WARN_ILL_ELLIPSIS = _ida_hexrays.WARN_ILL_ELLIPSIS
WARN_GUESSED_TYPE = _ida_hexrays.WARN_GUESSED_TYPE
WARN_EXP_LINVAR = _ida_hexrays.WARN_EXP_LINVAR
WARN_WIDEN_CHAINS = _ida_hexrays.WARN_WIDEN_CHAINS
WARN_BAD_PURGED = _ida_hexrays.WARN_BAD_PURGED
WARN_CBUILD_LOOPS = _ida_hexrays.WARN_CBUILD_LOOPS
WARN_NO_SAVE_REST = _ida_hexrays.WARN_NO_SAVE_REST
WARN_ODD_INPUT_REG = _ida_hexrays.WARN_ODD_INPUT_REG
WARN_ODD_ADDR_USE = _ida_hexrays.WARN_ODD_ADDR_USE
WARN_MUST_RET_FP = _ida_hexrays.WARN_MUST_RET_FP
WARN_ILL_FPU_STACK = _ida_hexrays.WARN_ILL_FPU_STACK
WARN_SELFREF_PROP = _ida_hexrays.WARN_SELFREF_PROP
WARN_WOULD_OVERLAP = _ida_hexrays.WARN_WOULD_OVERLAP
WARN_ARRAY_INARG = _ida_hexrays.WARN_ARRAY_INARG
WARN_MAX_ARGS = _ida_hexrays.WARN_MAX_ARGS
WARN_BAD_FIELD_TYPE = _ida_hexrays.WARN_BAD_FIELD_TYPE
WARN_WRITE_CONST = _ida_hexrays.WARN_WRITE_CONST
WARN_BAD_RETVAR = _ida_hexrays.WARN_BAD_RETVAR
WARN_FRAG_LVAR = _ida_hexrays.WARN_FRAG_LVAR
WARN_HUGE_STKOFF = _ida_hexrays.WARN_HUGE_STKOFF
WARN_UNINITED_REG = _ida_hexrays.WARN_UNINITED_REG
WARN_FIXED_MACRO = _ida_hexrays.WARN_FIXED_MACRO
WARN_WRONG_VA_OFF = _ida_hexrays.WARN_WRONG_VA_OFF
WARN_CR_NOFIELD = _ida_hexrays.WARN_CR_NOFIELD
WARN_CR_BADOFF = _ida_hexrays.WARN_CR_BADOFF
WARN_BAD_STROFF = _ida_hexrays.WARN_BAD_STROFF
WARN_BAD_VARSIZE = _ida_hexrays.WARN_BAD_VARSIZE
WARN_UNSUPP_REG = _ida_hexrays.WARN_UNSUPP_REG
WARN_UNALIGNED_ARG = _ida_hexrays.WARN_UNALIGNED_ARG
WARN_BAD_STD_TYPE = _ida_hexrays.WARN_BAD_STD_TYPE
WARN_BAD_CALL_SP = _ida_hexrays.WARN_BAD_CALL_SP
WARN_MISSED_SWITCH = _ida_hexrays.WARN_MISSED_SWITCH
WARN_BAD_SP = _ida_hexrays.WARN_BAD_SP
WARN_BAD_STKPNT = _ida_hexrays.WARN_BAD_STKPNT
WARN_UNDEF_LVAR = _ida_hexrays.WARN_UNDEF_LVAR
WARN_JUMPOUT = _ida_hexrays.WARN_JUMPOUT
WARN_BAD_VALRNG = _ida_hexrays.WARN_BAD_VALRNG
WARN_MAX = _ida_hexrays.WARN_MAX
class hexwarn_t(object):
    """
    Proxy of C++ hexwarn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.hexwarn_t_ea_get, _ida_hexrays.hexwarn_t_ea_set)
    id = _swig_property(_ida_hexrays.hexwarn_t_id_get, _ida_hexrays.hexwarn_t_id_set)
    text = _swig_property(_ida_hexrays.hexwarn_t_text_get, _ida_hexrays.hexwarn_t_text_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.hexwarn_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.hexwarn_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> hexwarn_t
        """
        this = _ida_hexrays.new_hexwarn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_hexwarn_t
    __del__ = lambda self : None;
hexwarn_t_swigregister = _ida_hexrays.hexwarn_t_swigregister
hexwarn_t_swigregister(hexwarn_t)
MAX_OPSIZE = cvar.MAX_OPSIZE
DOUBLE_OPSIZE = cvar.DOUBLE_OPSIZE

MMAT_ZERO = _ida_hexrays.MMAT_ZERO
MMAT_GENERATED = _ida_hexrays.MMAT_GENERATED
MMAT_PREOPTIMIZED = _ida_hexrays.MMAT_PREOPTIMIZED
MMAT_LOCOPT = _ida_hexrays.MMAT_LOCOPT
MMAT_CALLS = _ida_hexrays.MMAT_CALLS
MMAT_GLBOPT1 = _ida_hexrays.MMAT_GLBOPT1
MMAT_GLBOPT2 = _ida_hexrays.MMAT_GLBOPT2
MMAT_GLBOPT3 = _ida_hexrays.MMAT_GLBOPT3
MMAT_LVARS = _ida_hexrays.MMAT_LVARS
MMIDX_GLBLOW = _ida_hexrays.MMIDX_GLBLOW
MMIDX_LVARS = _ida_hexrays.MMIDX_LVARS
MMIDX_RETADDR = _ida_hexrays.MMIDX_RETADDR
MMIDX_SHADOW = _ida_hexrays.MMIDX_SHADOW
MMIDX_ARGS = _ida_hexrays.MMIDX_ARGS
MMIDX_GLBHIGH = _ida_hexrays.MMIDX_GLBHIGH
class codegen_t(object):
    """
    Proxy of C++ codegen_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.codegen_t_mba_get, _ida_hexrays.codegen_t_mba_set)
    mb = _swig_property(_ida_hexrays.codegen_t_mb_get, _ida_hexrays.codegen_t_mb_set)
    insn = _swig_property(_ida_hexrays.codegen_t_insn_get, _ida_hexrays.codegen_t_insn_set)
    ignore_micro = _swig_property(_ida_hexrays.codegen_t_ignore_micro_get, _ida_hexrays.codegen_t_ignore_micro_set)
    def __init__(self, *args):
        """
        __init__(self, m) -> codegen_t
        """
        if self.__class__ == codegen_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_codegen_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_codegen_t
    __del__ = lambda self : None;
    def analyze_prolog(self, *args):
        """
        analyze_prolog(self, fc, reachable) -> merror_t
        """
        return _ida_hexrays.codegen_t_analyze_prolog(self, *args)

    def gen_micro(self, *args):
        """
        gen_micro(self) -> merror_t
        """
        return _ida_hexrays.codegen_t_gen_micro(self, *args)

    def load_operand(self, *args):
        """
        load_operand(self, opnum) -> mreg_t
        """
        return _ida_hexrays.codegen_t_load_operand(self, *args)

    def emit_micro_mvm(self, *args):
        """
        emit_micro_mvm(self, code, dtype, l, r, d, offsize) -> minsn_t *
        """
        return _ida_hexrays.codegen_t_emit_micro_mvm(self, *args)

    def emit(self, *args):
        """
        emit(self, code, width, l, r, d, offsize) -> minsn_t
        emit(self, code, l, r, d) -> minsn_t *
        """
        return _ida_hexrays.codegen_t_emit(self, *args)

    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_codegen_t(self)
        return weakref_proxy(self)
codegen_t_swigregister = _ida_hexrays.codegen_t_swigregister
codegen_t_swigregister(codegen_t)


def get_hexrays_version(*args):
  """
  get_hexrays_version() -> char const *


  Get decompiler version. The returned string is of the form
  <major>.<minor>.<revision>.<build-date>
  
  @return: pointer to version string. For example: "2.0.0.140605"
  """
  return _ida_hexrays.get_hexrays_version(*args)

def open_pseudocode(*args):
  """
  open_pseudocode(ea, new_window) -> vdui_t


  Open pseudocode window. The specified function is decompiled and the
  pseudocode window is opened.
  
  @param ea: function to decompile (C++: ea_t)
  @param new_window: 0:reuse existing window; 1:open new window; -1:
                     reuse existing window if the current view is
                     pseudocode (C++: int)
  @return: false if failed
  """
  return _ida_hexrays.open_pseudocode(*args)

def close_pseudocode(*args):
  """
  close_pseudocode(f) -> bool


  Close pseudocode window.
  
  @param f: pointer to window (C++: TWidget *)
  @return: false if failed
  """
  return _ida_hexrays.close_pseudocode(*args)
VDRUN_NEWFILE = _ida_hexrays.VDRUN_NEWFILE
"""
Create a new file or overwrite existing file.
"""
VDRUN_APPEND = _ida_hexrays.VDRUN_APPEND
"""
Create a new file or append to existing file.
"""
VDRUN_ONLYNEW = _ida_hexrays.VDRUN_ONLYNEW
"""
Fail if output file already exists.
"""
VDRUN_SILENT = _ida_hexrays.VDRUN_SILENT
"""
Silent decompilation.
"""
VDRUN_SENDIDB = _ida_hexrays.VDRUN_SENDIDB
"""
Send problematic databases to hex-rays.com.
"""
VDRUN_MAYSTOP = _ida_hexrays.VDRUN_MAYSTOP
"""
the user can cancel decompilation
"""
VDRUN_CMDLINE = _ida_hexrays.VDRUN_CMDLINE
"""
called from ida's command line
"""
VDRUN_STATS = _ida_hexrays.VDRUN_STATS
"""
print statistics into vd_stats.txt
"""
VDRUN_LUMINA = _ida_hexrays.VDRUN_LUMINA
"""
use lumina server
"""
class hexrays_failure_t(object):
    """
    Proxy of C++ hexrays_failure_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    code = _swig_property(_ida_hexrays.hexrays_failure_t_code_get, _ida_hexrays.hexrays_failure_t_code_set)
    errea = _swig_property(_ida_hexrays.hexrays_failure_t_errea_get, _ida_hexrays.hexrays_failure_t_errea_set)
    str = _swig_property(_ida_hexrays.hexrays_failure_t_str_get, _ida_hexrays.hexrays_failure_t_str_set)
    def __init__(self, *args):
        """
        __init__(self) -> hexrays_failure_t
        __init__(self, c, ea, buf=None) -> hexrays_failure_t
        __init__(self, c, ea, buf) -> hexrays_failure_t
        """
        this = _ida_hexrays.new_hexrays_failure_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def desc(self, *args):
        """
        desc(self) -> qstring
        """
        return _ida_hexrays.hexrays_failure_t_desc(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_hexrays_failure_t
    __del__ = lambda self : None;
hexrays_failure_t_swigregister = _ida_hexrays.hexrays_failure_t_swigregister
hexrays_failure_t_swigregister(hexrays_failure_t)

class vd_failure_t(object):
    """
    Proxy of C++ vd_failure_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    hf = _swig_property(_ida_hexrays.vd_failure_t_hf_get, _ida_hexrays.vd_failure_t_hf_set)
    def __init__(self, *args):
        """
        __init__(self) -> vd_failure_t
        __init__(self, code, ea, buf=None) -> vd_failure_t
        __init__(self, code, ea, buf) -> vd_failure_t
        __init__(self, _hf) -> vd_failure_t
        """
        this = _ida_hexrays.new_vd_failure_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def desc(self, *args):
        """
        desc(self) -> qstring
        """
        return _ida_hexrays.vd_failure_t_desc(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vd_failure_t
    __del__ = lambda self : None;
vd_failure_t_swigregister = _ida_hexrays.vd_failure_t_swigregister
vd_failure_t_swigregister(vd_failure_t)

class vd_interr_t(vd_failure_t):
    """
    Proxy of C++ vd_interr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, ea, buf) -> vd_interr_t
        __init__(self, ea, buf) -> vd_interr_t
        """
        this = _ida_hexrays.new_vd_interr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_vd_interr_t
    __del__ = lambda self : None;
vd_interr_t_swigregister = _ida_hexrays.vd_interr_t_swigregister
vd_interr_t_swigregister(vd_interr_t)


def send_database(*args):
  """
  send_database(err, silent)


  Send the database to Hex-Rays. This function sends the current
  database to the Hex-Rays server. The database is sent in the
  compressed form over an encrypted (SSL) connection.
  
  @param err: failure description object. Empty  hexrays_failure_t
              object can be used if error information is not available.
              (C++: const  hexrays_failure_t  &)
  @param silent: if false, a dialog box will be displayed before sending
                 the database. (C++: bool)
  """
  return _ida_hexrays.send_database(*args)

def remitem(*args):
  """
  remitem(e)
  """
  return _ida_hexrays.remitem(*args)
cot_empty = _ida_hexrays.cot_empty
cot_comma = _ida_hexrays.cot_comma
cot_asg = _ida_hexrays.cot_asg
cot_asgbor = _ida_hexrays.cot_asgbor
cot_asgxor = _ida_hexrays.cot_asgxor
cot_asgband = _ida_hexrays.cot_asgband
cot_asgadd = _ida_hexrays.cot_asgadd
cot_asgsub = _ida_hexrays.cot_asgsub
cot_asgmul = _ida_hexrays.cot_asgmul
cot_asgsshr = _ida_hexrays.cot_asgsshr
cot_asgushr = _ida_hexrays.cot_asgushr
cot_asgshl = _ida_hexrays.cot_asgshl
cot_asgsdiv = _ida_hexrays.cot_asgsdiv
cot_asgudiv = _ida_hexrays.cot_asgudiv
cot_asgsmod = _ida_hexrays.cot_asgsmod
cot_asgumod = _ida_hexrays.cot_asgumod
cot_tern = _ida_hexrays.cot_tern
cot_lor = _ida_hexrays.cot_lor
cot_land = _ida_hexrays.cot_land
cot_bor = _ida_hexrays.cot_bor
cot_xor = _ida_hexrays.cot_xor
cot_band = _ida_hexrays.cot_band
cot_eq = _ida_hexrays.cot_eq
cot_ne = _ida_hexrays.cot_ne
cot_sge = _ida_hexrays.cot_sge
cot_uge = _ida_hexrays.cot_uge
cot_sle = _ida_hexrays.cot_sle
cot_ule = _ida_hexrays.cot_ule
cot_sgt = _ida_hexrays.cot_sgt
cot_ugt = _ida_hexrays.cot_ugt
cot_slt = _ida_hexrays.cot_slt
cot_ult = _ida_hexrays.cot_ult
cot_sshr = _ida_hexrays.cot_sshr
cot_ushr = _ida_hexrays.cot_ushr
cot_shl = _ida_hexrays.cot_shl
cot_add = _ida_hexrays.cot_add
cot_sub = _ida_hexrays.cot_sub
cot_mul = _ida_hexrays.cot_mul
cot_sdiv = _ida_hexrays.cot_sdiv
cot_udiv = _ida_hexrays.cot_udiv
cot_smod = _ida_hexrays.cot_smod
cot_umod = _ida_hexrays.cot_umod
cot_fadd = _ida_hexrays.cot_fadd
cot_fsub = _ida_hexrays.cot_fsub
cot_fmul = _ida_hexrays.cot_fmul
cot_fdiv = _ida_hexrays.cot_fdiv
cot_fneg = _ida_hexrays.cot_fneg
cot_neg = _ida_hexrays.cot_neg
cot_cast = _ida_hexrays.cot_cast
cot_lnot = _ida_hexrays.cot_lnot
cot_bnot = _ida_hexrays.cot_bnot
cot_ptr = _ida_hexrays.cot_ptr
cot_ref = _ida_hexrays.cot_ref
cot_postinc = _ida_hexrays.cot_postinc
cot_postdec = _ida_hexrays.cot_postdec
cot_preinc = _ida_hexrays.cot_preinc
cot_predec = _ida_hexrays.cot_predec
cot_call = _ida_hexrays.cot_call
cot_idx = _ida_hexrays.cot_idx
cot_memref = _ida_hexrays.cot_memref
cot_memptr = _ida_hexrays.cot_memptr
cot_num = _ida_hexrays.cot_num
cot_fnum = _ida_hexrays.cot_fnum
cot_str = _ida_hexrays.cot_str
cot_obj = _ida_hexrays.cot_obj
cot_var = _ida_hexrays.cot_var
cot_insn = _ida_hexrays.cot_insn
cot_sizeof = _ida_hexrays.cot_sizeof
cot_helper = _ida_hexrays.cot_helper
cot_type = _ida_hexrays.cot_type
cot_last = _ida_hexrays.cot_last
cit_empty = _ida_hexrays.cit_empty
cit_block = _ida_hexrays.cit_block
cit_expr = _ida_hexrays.cit_expr
cit_if = _ida_hexrays.cit_if
cit_for = _ida_hexrays.cit_for
cit_while = _ida_hexrays.cit_while
cit_do = _ida_hexrays.cit_do
cit_switch = _ida_hexrays.cit_switch
cit_break = _ida_hexrays.cit_break
cit_continue = _ida_hexrays.cit_continue
cit_return = _ida_hexrays.cit_return
cit_goto = _ida_hexrays.cit_goto
cit_asm = _ida_hexrays.cit_asm
cit_end = _ida_hexrays.cit_end
class operator_info_t(object):
    """
    Proxy of C++ operator_info_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    text = _swig_property(_ida_hexrays.operator_info_t_text_get, _ida_hexrays.operator_info_t_text_set)
    precedence = _swig_property(_ida_hexrays.operator_info_t_precedence_get, _ida_hexrays.operator_info_t_precedence_set)
    valency = _swig_property(_ida_hexrays.operator_info_t_valency_get, _ida_hexrays.operator_info_t_valency_set)
    fixtype = _swig_property(_ida_hexrays.operator_info_t_fixtype_get, _ida_hexrays.operator_info_t_fixtype_set)
    flags = _swig_property(_ida_hexrays.operator_info_t_flags_get, _ida_hexrays.operator_info_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> operator_info_t
        """
        this = _ida_hexrays.new_operator_info_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_operator_info_t
    __del__ = lambda self : None;
operator_info_t_swigregister = _ida_hexrays.operator_info_t_swigregister
operator_info_t_swigregister(operator_info_t)
FX_NONE = cvar.FX_NONE
FX_INFIX = cvar.FX_INFIX
FX_PREFIX = cvar.FX_PREFIX
FX_POSTFIX = cvar.FX_POSTFIX
FX_TERNARY = cvar.FX_TERNARY
COI_RL = cvar.COI_RL
COI_LR = cvar.COI_LR
COI_INT = cvar.COI_INT
COI_FP = cvar.COI_FP
COI_SH = cvar.COI_SH
COI_SGN = cvar.COI_SGN
COI_SBN = cvar.COI_SBN


def negated_relation(*args):
  """
  negated_relation(op) -> ctype_t


  Negate a comparison operator. For example, cot_sge becomes cot_slt.
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.negated_relation(*args)

def swapped_relation(*args):
  """
  swapped_relation(op) -> ctype_t


  Swap a comparison operator. For example, cot_sge becomes cot_sle.
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.swapped_relation(*args)

def get_op_signness(*args):
  """
  get_op_signness(op) -> type_sign_t


  Get operator sign. Meaningful for sign-dependent operators, like
  cot_sdiv.
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.get_op_signness(*args)

def asgop(*args):
  """
  asgop(cop) -> ctype_t


  Convert plain operator into assignment operator. For example, cot_add
  returns cot_asgadd.
  
  
  @param cop (C++: ctype_t)
  """
  return _ida_hexrays.asgop(*args)

def asgop_revert(*args):
  """
  asgop_revert(cop) -> ctype_t


  Convert assignment operator into plain operator. For example,
  cot_asgadd returns cot_add
  
  @param cop (C++: ctype_t)
  @return: cot_empty is the input operator is not an assignment
           operator.
  """
  return _ida_hexrays.asgop_revert(*args)

def op_uses_x(*args):
  """
  op_uses_x(op) -> bool


  Does operator use the 'x' field of 'cexpr_t' ?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.op_uses_x(*args)

def op_uses_y(*args):
  """
  op_uses_y(op) -> bool


  Does operator use the 'y' field of 'cexpr_t' ?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.op_uses_y(*args)

def op_uses_z(*args):
  """
  op_uses_z(op) -> bool


  Does operator use the 'z' field of 'cexpr_t' ?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.op_uses_z(*args)

def is_binary(*args):
  """
  is_binary(op) -> bool


  Is binary operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_binary(*args)

def is_unary(*args):
  """
  is_unary(op) -> bool


  Is unary operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_unary(*args)

def is_relational(*args):
  """
  is_relational(op) -> bool


  Is comparison operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_relational(*args)

def is_assignment(*args):
  """
  is_assignment(op) -> bool


  Is assignment operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_assignment(*args)

def accepts_udts(*args):
  """
  accepts_udts(op) -> bool
  """
  return _ida_hexrays.accepts_udts(*args)

def is_prepost(*args):
  """
  is_prepost(op) -> bool


  Is pre/post increment/decrement operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_prepost(*args)

def is_commutative(*args):
  """
  is_commutative(op) -> bool


  Is commutative operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_commutative(*args)

def is_additive(*args):
  """
  is_additive(op) -> bool


  Is additive operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_additive(*args)

def is_multiplicative(*args):
  """
  is_multiplicative(op) -> bool


  Is multiplicative operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_multiplicative(*args)

def is_bitop(*args):
  """
  is_bitop(op) -> bool


  Is bit related operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_bitop(*args)

def is_logical(*args):
  """
  is_logical(op) -> bool


  Is logical operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_logical(*args)

def is_loop(*args):
  """
  is_loop(op) -> bool


  Is loop statement code?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_loop(*args)

def is_break_consumer(*args):
  """
  is_break_consumer(op) -> bool


  Does a break statement influence the specified statement code?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_break_consumer(*args)

def is_lvalue(*args):
  """
  is_lvalue(op) -> bool


  Is Lvalue operator?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_lvalue(*args)

def is_allowed_on_small_struni(*args):
  """
  is_allowed_on_small_struni(op) -> bool


  Is the operator allowed on small struni (structure/union)?
  
  
  @param op (C++: ctype_t)
  """
  return _ida_hexrays.is_allowed_on_small_struni(*args)
class cnumber_t(object):
    """
    Proxy of C++ cnumber_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _value = _swig_property(_ida_hexrays.cnumber_t__value_get, _ida_hexrays.cnumber_t__value_set)
    nf = _swig_property(_ida_hexrays.cnumber_t_nf_get, _ida_hexrays.cnumber_t_nf_set)
    def __init__(self, *args):
        """
        __init__(self, _opnum=0) -> cnumber_t
        """
        this = _ida_hexrays.new_cnumber_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def _print(self, *args):
        """
        _print(self, type, parent=None, nice_stroff=None)
        """
        return _ida_hexrays.cnumber_t__print(self, *args)

    def value(self, *args):
        """
        value(self, type) -> uint64
        """
        return _ida_hexrays.cnumber_t_value(self, *args)

    def assign(self, *args):
        """
        assign(self, v, nbytes, sign)
        """
        return _ida_hexrays.cnumber_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cnumber_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cnumber_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cnumber_t
    __del__ = lambda self : None;
cnumber_t_swigregister = _ida_hexrays.cnumber_t_swigregister
cnumber_t_swigregister(cnumber_t)

class var_ref_t(object):
    """
    Proxy of C++ var_ref_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mba = _swig_property(_ida_hexrays.var_ref_t_mba_get, _ida_hexrays.var_ref_t_mba_set)
    idx = _swig_property(_ida_hexrays.var_ref_t_idx_get, _ida_hexrays.var_ref_t_idx_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.var_ref_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.var_ref_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> var_ref_t
        """
        this = _ida_hexrays.new_var_ref_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_var_ref_t
    __del__ = lambda self : None;
var_ref_t_swigregister = _ida_hexrays.var_ref_t_swigregister
var_ref_t_swigregister(var_ref_t)

class ctree_visitor_t(object):
    """
    Proxy of C++ ctree_visitor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cv_flags = _swig_property(_ida_hexrays.ctree_visitor_t_cv_flags_get, _ida_hexrays.ctree_visitor_t_cv_flags_set)
    def maintain_parents(self, *args):
        """
        maintain_parents(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_maintain_parents(self, *args)

    def must_prune(self, *args):
        """
        must_prune(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_must_prune(self, *args)

    def must_restart(self, *args):
        """
        must_restart(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_must_restart(self, *args)

    def is_postorder(self, *args):
        """
        is_postorder(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_is_postorder(self, *args)

    def only_insns(self, *args):
        """
        only_insns(self) -> bool
        """
        return _ida_hexrays.ctree_visitor_t_only_insns(self, *args)

    def prune_now(self, *args):
        """
        prune_now(self)
        """
        return _ida_hexrays.ctree_visitor_t_prune_now(self, *args)

    def clr_prune(self, *args):
        """
        clr_prune(self)
        """
        return _ida_hexrays.ctree_visitor_t_clr_prune(self, *args)

    def set_restart(self, *args):
        """
        set_restart(self)
        """
        return _ida_hexrays.ctree_visitor_t_set_restart(self, *args)

    def clr_restart(self, *args):
        """
        clr_restart(self)
        """
        return _ida_hexrays.ctree_visitor_t_clr_restart(self, *args)

    parents = _swig_property(_ida_hexrays.ctree_visitor_t_parents_get, _ida_hexrays.ctree_visitor_t_parents_set)
    def __init__(self, *args):
        """
        __init__(self, _flags) -> ctree_visitor_t
        """
        if self.__class__ == ctree_visitor_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_ctree_visitor_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def apply_to(self, *args):
        """
        apply_to(self, item, parent) -> int
        """
        return _ida_hexrays.ctree_visitor_t_apply_to(self, *args)

    def apply_to_exprs(self, *args):
        """
        apply_to_exprs(self, item, parent) -> int
        """
        return _ida_hexrays.ctree_visitor_t_apply_to_exprs(self, *args)

    def parent_expr(self, *args):
        """
        parent_expr(self) -> cexpr_t
        """
        return _ida_hexrays.ctree_visitor_t_parent_expr(self, *args)

    def parent_insn(self, *args):
        """
        parent_insn(self) -> cinsn_t
        """
        return _ida_hexrays.ctree_visitor_t_parent_insn(self, *args)

    def visit_insn(self, *args):
        """
        visit_insn(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_visit_insn(self, *args)

    def visit_expr(self, *args):
        """
        visit_expr(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_visit_expr(self, *args)

    def leave_insn(self, *args):
        """
        leave_insn(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_leave_insn(self, *args)

    def leave_expr(self, *args):
        """
        leave_expr(self, arg0) -> int
        """
        return _ida_hexrays.ctree_visitor_t_leave_expr(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ctree_visitor_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_ctree_visitor_t(self)
        return weakref_proxy(self)
ctree_visitor_t_swigregister = _ida_hexrays.ctree_visitor_t_swigregister
ctree_visitor_t_swigregister(ctree_visitor_t)
CV_FAST = _ida_hexrays.CV_FAST
"""
do not maintain parent information
"""
CV_PRUNE = _ida_hexrays.CV_PRUNE
"""
this bit is set by visit...() to prune the walk
"""
CV_PARENTS = _ida_hexrays.CV_PARENTS
"""
maintain parent information
"""
CV_POST = _ida_hexrays.CV_POST
"""
call the leave...() functions
"""
CV_RESTART = _ida_hexrays.CV_RESTART
"""
restart enumeration at the top expr (apply_to_exprs)
"""
CV_INSNS = _ida_hexrays.CV_INSNS
"""
visit only statements, prune all expressions do not use before the
final ctree maturity because expressions may contain statements at
intermediate stages (see cot_insn). Otherwise you risk missing
statements embedded into expressions.
"""

class ctree_parentee_t(ctree_visitor_t):
    """
    Proxy of C++ ctree_parentee_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, post=False) -> ctree_parentee_t
        """
        if self.__class__ == ctree_parentee_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_ctree_parentee_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def recalc_parent_types(self, *args):
        """
        recalc_parent_types(self) -> bool
        """
        return _ida_hexrays.ctree_parentee_t_recalc_parent_types(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ctree_parentee_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_ctree_parentee_t(self)
        return weakref_proxy(self)
ctree_parentee_t_swigregister = _ida_hexrays.ctree_parentee_t_swigregister
ctree_parentee_t_swigregister(ctree_parentee_t)

class cfunc_parentee_t(ctree_parentee_t):
    """
    Proxy of C++ cfunc_parentee_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    func = _swig_property(_ida_hexrays.cfunc_parentee_t_func_get, _ida_hexrays.cfunc_parentee_t_func_set)
    def __init__(self, *args):
        """
        __init__(self, f, post=False) -> cfunc_parentee_t
        """
        if self.__class__ == cfunc_parentee_t:
            _self = None
        else:
            _self = self
        this = _ida_hexrays.new_cfunc_parentee_t(_self, *args)
        try: self.this.append(this)
        except: self.this = this
    def calc_rvalue_type(self, *args):
        """
        calc_rvalue_type(self, target, e) -> bool
        """
        return _ida_hexrays.cfunc_parentee_t_calc_rvalue_type(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cfunc_parentee_t
    __del__ = lambda self : None;
    def __disown__(self):
        self.this.disown()
        _ida_hexrays.disown_cfunc_parentee_t(self)
        return weakref_proxy(self)
cfunc_parentee_t_swigregister = _ida_hexrays.cfunc_parentee_t_swigregister
cfunc_parentee_t_swigregister(cfunc_parentee_t)

CMAT_ZERO = _ida_hexrays.CMAT_ZERO
CMAT_BUILT = _ida_hexrays.CMAT_BUILT
CMAT_TRANS1 = _ida_hexrays.CMAT_TRANS1
CMAT_NICE = _ida_hexrays.CMAT_NICE
CMAT_TRANS2 = _ida_hexrays.CMAT_TRANS2
CMAT_CPA = _ida_hexrays.CMAT_CPA
CMAT_TRANS3 = _ida_hexrays.CMAT_TRANS3
CMAT_CASTED = _ida_hexrays.CMAT_CASTED
CMAT_FINAL = _ida_hexrays.CMAT_FINAL
ITP_EMPTY = _ida_hexrays.ITP_EMPTY
ITP_ARG1 = _ida_hexrays.ITP_ARG1
ITP_ARG64 = _ida_hexrays.ITP_ARG64
ITP_BRACE1 = _ida_hexrays.ITP_BRACE1
ITP_INNER_LAST = _ida_hexrays.ITP_INNER_LAST
ITP_ASM = _ida_hexrays.ITP_ASM
ITP_ELSE = _ida_hexrays.ITP_ELSE
ITP_DO = _ida_hexrays.ITP_DO
ITP_SEMI = _ida_hexrays.ITP_SEMI
ITP_CURLY1 = _ida_hexrays.ITP_CURLY1
ITP_CURLY2 = _ida_hexrays.ITP_CURLY2
ITP_BRACE2 = _ida_hexrays.ITP_BRACE2
ITP_COLON = _ida_hexrays.ITP_COLON
ITP_BLOCK1 = _ida_hexrays.ITP_BLOCK1
ITP_BLOCK2 = _ida_hexrays.ITP_BLOCK2
ITP_CASE = _ida_hexrays.ITP_CASE
ITP_SIGN = _ida_hexrays.ITP_SIGN
class treeloc_t(object):
    """
    Proxy of C++ treeloc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.treeloc_t_ea_get, _ida_hexrays.treeloc_t_ea_set)
    itp = _swig_property(_ida_hexrays.treeloc_t_itp_get, _ida_hexrays.treeloc_t_itp_set)
    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.treeloc_t___lt__(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.treeloc_t___eq__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> treeloc_t
        """
        this = _ida_hexrays.new_treeloc_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_treeloc_t
    __del__ = lambda self : None;
treeloc_t_swigregister = _ida_hexrays.treeloc_t_swigregister
treeloc_t_swigregister(treeloc_t)

RETRIEVE_ONCE = _ida_hexrays.RETRIEVE_ONCE
RETRIEVE_ALWAYS = _ida_hexrays.RETRIEVE_ALWAYS
class citem_cmt_t(object):
    """
    Proxy of C++ citem_cmt_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    used = _swig_property(_ida_hexrays.citem_cmt_t_used_get, _ida_hexrays.citem_cmt_t_used_set)
    def __init__(self, *args):
        """
        __init__(self) -> citem_cmt_t
        __init__(self, s) -> citem_cmt_t
        """
        this = _ida_hexrays.new_citem_cmt_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def c_str(self, *args):
        """
        c_str(self) -> char const *
        """
        return _ida_hexrays.citem_cmt_t_c_str(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> char const *
        """
        return _ida_hexrays.citem_cmt_t___str__(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_citem_cmt_t
    __del__ = lambda self : None;
citem_cmt_t_swigregister = _ida_hexrays.citem_cmt_t_swigregister
citem_cmt_t_swigregister(citem_cmt_t)

class citem_locator_t(object):
    """
    Proxy of C++ citem_locator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.citem_locator_t_ea_get, _ida_hexrays.citem_locator_t_ea_set)
    op = _swig_property(_ida_hexrays.citem_locator_t_op_get, _ida_hexrays.citem_locator_t_op_set)
    def __init__(self, *args):
        """
        __init__(self, _ea, _op) -> citem_locator_t
        __init__(self, i) -> citem_locator_t
        """
        this = _ida_hexrays.new_citem_locator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.citem_locator_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.citem_locator_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_citem_locator_t
    __del__ = lambda self : None;
citem_locator_t_swigregister = _ida_hexrays.citem_locator_t_swigregister
citem_locator_t_swigregister(citem_locator_t)

class bit_bound_t(object):
    """
    Proxy of C++ bit_bound_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nbits = _swig_property(_ida_hexrays.bit_bound_t_nbits_get, _ida_hexrays.bit_bound_t_nbits_set)
    sbits = _swig_property(_ida_hexrays.bit_bound_t_sbits_get, _ida_hexrays.bit_bound_t_sbits_set)
    def __init__(self, *args):
        """
        __init__(self, n=0, s=0) -> bit_bound_t
        """
        this = _ida_hexrays.new_bit_bound_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_bit_bound_t
    __del__ = lambda self : None;
bit_bound_t_swigregister = _ida_hexrays.bit_bound_t_swigregister
bit_bound_t_swigregister(bit_bound_t)

class citem_t(object):
    """
    Proxy of C++ citem_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.citem_t_ea_get, _ida_hexrays.citem_t_ea_set)
    label_num = _swig_property(_ida_hexrays.citem_t_label_num_get, _ida_hexrays.citem_t_label_num_set)
    index = _swig_property(_ida_hexrays.citem_t_index_get, _ida_hexrays.citem_t_index_set)
    def __init__(self, *args):
        """
        __init__(self) -> citem_t
        __init__(self, o) -> citem_t
        """
        this = _ida_hexrays.new_citem_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.citem_t_swap(self, *args)

    def is_expr(self, *args):
        """
        is_expr(self) -> bool
        """
        return _ida_hexrays.citem_t_is_expr(self, *args)

    def contains_expr(self, *args):
        """
        contains_expr(self, e) -> bool
        """
        return _ida_hexrays.citem_t_contains_expr(self, *args)

    def contains_label(self, *args):
        """
        contains_label(self) -> bool
        """
        return _ida_hexrays.citem_t_contains_label(self, *args)

    def find_parent_of(self, *args):
        """
        find_parent_of(self, sitem) -> citem_t
        find_parent_of(self, item) -> citem_t
        """
        return _ida_hexrays.citem_t_find_parent_of(self, *args)

    def find_closest_addr(self, *args):
        """
        find_closest_addr(self, _ea) -> citem_t
        """
        return _ida_hexrays.citem_t_find_closest_addr(self, *args)

    def print1(self, *args):
        """
        print1(self, func)
        """
        return _ida_hexrays.citem_t_print1(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_citem_t
    __del__ = lambda self : None;
    cinsn = _swig_property(_ida_hexrays.citem_t_cinsn_get)
    cexpr = _swig_property(_ida_hexrays.citem_t_cexpr_get)
    def _get_op(self, *args):
        """
        _get_op(self) -> ctype_t
        """
        return _ida_hexrays.citem_t__get_op(self, *args)

    def _set_op(self, *args):
        """
        _set_op(self, v)
        """
        return _ida_hexrays.citem_t__set_op(self, *args)

    def _obj_id(self, *args):
        """
        _obj_id(self) -> PyObject *
        """
        return _ida_hexrays.citem_t__obj_id(self, *args)

    obj_id = property(_obj_id)
    op = property(
            _get_op,
            lambda self, v: self._ensure_no_op() and self._set_op(v))

    def _ensure_cond(self, ok, cond_str):
        if not ok:
            raise Exception("Condition \"%s\" not verified" % cond_str)
        return True

    def _ensure_no_op(self):
        if self.op not in [cot_empty, cit_empty]:
            raise Exception("%s has op %s; cannot be modified" % (self, self.op))
        return True

    def _ensure_no_obj(self, o, attr, attr_is_acquired):
        if attr_is_acquired and o is not None:
            raise Exception("%s already owns attribute \"%s\" (%s); cannot be modified" % (self, attr, o))
        return True

    def _acquire_ownership(self, v, acquire):
        if acquire and (v is not None) and not isinstance(v, (int, long)):
            if not v.thisown:
                raise Exception("%s is already owned, and cannot be reused" % v)
            v.thisown = False
            dereg = getattr(v, "_deregister", None)
            if dereg:
                dereg()
        return True

    def _maybe_disown_and_deregister(self):
        if self.thisown:
            self.thisown = False
            self._deregister()

    def _own_and_register(self):
        assert(not self.thisown)
        self.thisown = True
        self._register()

    def replace_by(self, o):
        assert(isinstance(o, (cexpr_t, cinsn_t)))
        o._maybe_disown_and_deregister()
        self._replace_by(o)


















citem_t_swigregister = _ida_hexrays.citem_t_swigregister
citem_t_swigregister(citem_t)

class cexpr_t(citem_t):
    """
    Proxy of C++ cexpr_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    type = _swig_property(_ida_hexrays.cexpr_t_type_get, _ida_hexrays.cexpr_t_type_set)
    exflags = _swig_property(_ida_hexrays.cexpr_t_exflags_get, _ida_hexrays.cexpr_t_exflags_set)
    def cpadone(self, *args):
        """
        cpadone(self) -> bool
        """
        return _ida_hexrays.cexpr_t_cpadone(self, *args)

    def is_odd_lvalue(self, *args):
        """
        is_odd_lvalue(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_odd_lvalue(self, *args)

    def is_fpop(self, *args):
        """
        is_fpop(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_fpop(self, *args)

    def is_cstr(self, *args):
        """
        is_cstr(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_cstr(self, *args)

    def is_undef_val(self, *args):
        """
        is_undef_val(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_undef_val(self, *args)

    def is_jumpout(self, *args):
        """
        is_jumpout(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_jumpout(self, *args)

    def is_vftable(self, *args):
        """
        is_vftable(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_vftable(self, *args)

    def set_cpadone(self, *args):
        """
        set_cpadone(self)
        """
        return _ida_hexrays.cexpr_t_set_cpadone(self, *args)

    def set_vftable(self, *args):
        """
        set_vftable(self)
        """
        return _ida_hexrays.cexpr_t_set_vftable(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cexpr_t
        __init__(self, cop, _x) -> cexpr_t
        __init__(self, cop, _x, _y) -> cexpr_t
        __init__(self, cop, _x, _y, _z) -> cexpr_t
        __init__(self, r) -> cexpr_t
        """
        this = _ida_hexrays.new_cexpr_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.cexpr_t_swap(self, *args)

    def assign(self, *args):
        """
        assign(self, r) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cexpr_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cexpr_t
    __del__ = lambda self : None;
    def _replace_by(self, *args):
        """
        _replace_by(self, r)
        """
        return _ida_hexrays.cexpr_t__replace_by(self, *args)

    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cexpr_t_cleanup(self, *args)

    def put_number(self, *args):
        """
        put_number(self, func, value, nbytes, sign=no_sign)
        """
        return _ida_hexrays.cexpr_t_put_number(self, *args)

    def print1(self, *args):
        """
        print1(self, func)
        """
        return _ida_hexrays.cexpr_t_print1(self, *args)

    def calc_type(self, *args):
        """
        calc_type(self, recursive)
        """
        return _ida_hexrays.cexpr_t_calc_type(self, *args)

    def equal_effect(self, *args):
        """
        equal_effect(self, r) -> bool
        """
        return _ida_hexrays.cexpr_t_equal_effect(self, *args)

    def is_child_of(self, *args):
        """
        is_child_of(self, parent) -> bool
        """
        return _ida_hexrays.cexpr_t_is_child_of(self, *args)

    def contains_operator(self, *args):
        """
        contains_operator(self, needed_op, times=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_operator(self, *args)

    def contains_comma(self, *args):
        """
        contains_comma(self, times=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_comma(self, *args)

    def contains_insn(self, *args):
        """
        contains_insn(self, times=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_insn(self, *args)

    def contains_insn_or_label(self, *args):
        """
        contains_insn_or_label(self) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_insn_or_label(self, *args)

    def contains_comma_or_insn_or_label(self, *args):
        """
        contains_comma_or_insn_or_label(self, maxcommas=1) -> bool
        """
        return _ida_hexrays.cexpr_t_contains_comma_or_insn_or_label(self, *args)

    def is_nice_expr(self, *args):
        """
        is_nice_expr(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_nice_expr(self, *args)

    def is_nice_cond(self, *args):
        """
        is_nice_cond(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_nice_cond(self, *args)

    def is_call_object_of(self, *args):
        """
        is_call_object_of(self, parent) -> bool
        """
        return _ida_hexrays.cexpr_t_is_call_object_of(self, *args)

    def is_call_arg_of(self, *args):
        """
        is_call_arg_of(self, parent) -> bool
        """
        return _ida_hexrays.cexpr_t_is_call_arg_of(self, *args)

    def get_type_sign(self, *args):
        """
        get_type_sign(self) -> type_sign_t
        """
        return _ida_hexrays.cexpr_t_get_type_sign(self, *args)

    def is_type_unsigned(self, *args):
        """
        is_type_unsigned(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_type_unsigned(self, *args)

    def is_type_signed(self, *args):
        """
        is_type_signed(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_type_signed(self, *args)

    def get_high_nbit_bound(self, *args):
        """
        get_high_nbit_bound(self) -> bit_bound_t
        """
        return _ida_hexrays.cexpr_t_get_high_nbit_bound(self, *args)

    def get_low_nbit_bound(self, *args):
        """
        get_low_nbit_bound(self) -> int
        """
        return _ida_hexrays.cexpr_t_get_low_nbit_bound(self, *args)

    def requires_lvalue(self, *args):
        """
        requires_lvalue(self, child) -> bool
        """
        return _ida_hexrays.cexpr_t_requires_lvalue(self, *args)

    def has_side_effects(self, *args):
        """
        has_side_effects(self) -> bool
        """
        return _ida_hexrays.cexpr_t_has_side_effects(self, *args)

    def numval(self, *args):
        """
        numval(self) -> uint64
        """
        return _ida_hexrays.cexpr_t_numval(self, *args)

    def is_const_value(self, *args):
        """
        is_const_value(self, _v) -> bool
        """
        return _ida_hexrays.cexpr_t_is_const_value(self, *args)

    def is_negative_const(self, *args):
        """
        is_negative_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_negative_const(self, *args)

    def is_non_negative_const(self, *args):
        """
        is_non_negative_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_non_negative_const(self, *args)

    def is_non_zero_const(self, *args):
        """
        is_non_zero_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_non_zero_const(self, *args)

    def is_zero_const(self, *args):
        """
        is_zero_const(self) -> bool
        """
        return _ida_hexrays.cexpr_t_is_zero_const(self, *args)

    def get_const_value(self, *args):
        """
        get_const_value(self) -> bool
        """
        return _ida_hexrays.cexpr_t_get_const_value(self, *args)

    def maybe_ptr(self, *args):
        """
        maybe_ptr(self) -> bool
        """
        return _ida_hexrays.cexpr_t_maybe_ptr(self, *args)

    def get_ptr_or_array(self, *args):
        """
        get_ptr_or_array(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_get_ptr_or_array(self, *args)

    def find_op(self, *args):
        """
        find_op(self, _op) -> cexpr_t
        find_op(self, _op) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_find_op(self, *args)

    def find_num_op(self, *args):
        """
        find_num_op(self) -> cexpr_t
        find_num_op(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_find_num_op(self, *args)

    def theother(self, *args):
        """
        theother(self, what) -> cexpr_t
        theother(self, what) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t_theother(self, *args)

    def get_1num_op(self, *args):
        """
        get_1num_op(self, o1, o2) -> bool
        """
        return _ida_hexrays.cexpr_t_get_1num_op(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.cexpr_t__deregister(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.cexpr_t__register(self, *args)

    def _get_n(self, *args):
        """
        _get_n(self) -> cnumber_t
        """
        return _ida_hexrays.cexpr_t__get_n(self, *args)

    def _set_n(self, *args):
        """
        _set_n(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_n(self, *args)

    n = property(                                                                lambda self: self._get_n() if self.op == cot_num else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_num,"self.op == cot_num")                                           and self._ensure_no_obj(self._get_n(),"n", True)                  and self._acquire_ownership(v, True)                                  and self._set_n(v))
    def _get_fpc(self, *args):
        """
        _get_fpc(self) -> fnumber_t
        """
        return _ida_hexrays.cexpr_t__get_fpc(self, *args)

    def _set_fpc(self, *args):
        """
        _set_fpc(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_fpc(self, *args)

    fpc = property(                                                                lambda self: self._get_fpc() if self.op == cot_fnum else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_fnum,"self.op == cot_fnum")                                           and self._ensure_no_obj(self._get_fpc(),"fpc", True)                  and self._acquire_ownership(v, True)                                  and self._set_fpc(v))
    def get_v(self, *args):
        """
        get_v(self) -> var_ref_t
        """
        return _ida_hexrays.cexpr_t_get_v(self, *args)

    def set_v(self, *args):
        """
        set_v(self, v)
        """
        return _ida_hexrays.cexpr_t_set_v(self, *args)

    v = property(lambda self: self.get_v(), lambda self, v: self.set_v(v))

    def _get_obj_ea(self, *args):
        """
        _get_obj_ea(self) -> ea_t
        """
        return _ida_hexrays.cexpr_t__get_obj_ea(self, *args)

    def _set_obj_ea(self, *args):
        """
        _set_obj_ea(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_obj_ea(self, *args)

    obj_ea = property(                                                                lambda self: self._get_obj_ea() if self.op == cot_obj else ida_idaapi.BADADDR,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_obj,"self.op == cot_obj")                                           and self._ensure_no_obj(self._get_obj_ea(),"obj_ea", False)                  and self._acquire_ownership(v, False)                                  and self._set_obj_ea(v))
    def _get_refwidth(self, *args):
        """
        _get_refwidth(self) -> int
        """
        return _ida_hexrays.cexpr_t__get_refwidth(self, *args)

    def _set_refwidth(self, *args):
        """
        _set_refwidth(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_refwidth(self, *args)

    refwidth = property(                                                                lambda self: self._get_refwidth() if True else 0,                    lambda self, v:                                                              self._ensure_cond(True,"True")                                           and self._ensure_no_obj(self._get_refwidth(),"refwidth", False)                  and self._acquire_ownership(v, False)                                  and self._set_refwidth(v))
    def _get_x(self, *args):
        """
        _get_x(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t__get_x(self, *args)

    def _set_x(self, *args):
        """
        _set_x(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_x(self, *args)

    x = property(                                                                lambda self: self._get_x() if op_uses_x(self.op) else None,                    lambda self, v:                                                              self._ensure_cond(op_uses_x(self.op),"op_uses_x(self.op)")                                           and self._ensure_no_obj(self._get_x(),"x", True)                  and self._acquire_ownership(v, True)                                  and self._set_x(v))
    def _get_y(self, *args):
        """
        _get_y(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t__get_y(self, *args)

    def _set_y(self, *args):
        """
        _set_y(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_y(self, *args)

    y = property(                                                                lambda self: self._get_y() if op_uses_y(self.op) else None,                    lambda self, v:                                                              self._ensure_cond(op_uses_y(self.op),"op_uses_y(self.op)")                                           and self._ensure_no_obj(self._get_y(),"y", True)                  and self._acquire_ownership(v, True)                                  and self._set_y(v))
    def _get_a(self, *args):
        """
        _get_a(self) -> carglist_t
        """
        return _ida_hexrays.cexpr_t__get_a(self, *args)

    def _set_a(self, *args):
        """
        _set_a(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_a(self, *args)

    a = property(                                                                lambda self: self._get_a() if self.op == cot_call else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_call,"self.op == cot_call")                                           and self._ensure_no_obj(self._get_a(),"a", True)                  and self._acquire_ownership(v, True)                                  and self._set_a(v))
    def _get_m(self, *args):
        """
        _get_m(self) -> int
        """
        return _ida_hexrays.cexpr_t__get_m(self, *args)

    def _set_m(self, *args):
        """
        _set_m(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_m(self, *args)

    m = property(                                                                lambda self: self._get_m() if (self.op == cot_memptr or self.op == cot_memref) else 0,                    lambda self, v:                                                              self._ensure_cond((self.op == cot_memptr or self.op == cot_memref),"(self.op == cot_memptr or self.op == cot_memref)")                                           and self._ensure_no_obj(self._get_m(),"m", False)                  and self._acquire_ownership(v, False)                                  and self._set_m(v))
    def _get_z(self, *args):
        """
        _get_z(self) -> cexpr_t
        """
        return _ida_hexrays.cexpr_t__get_z(self, *args)

    def _set_z(self, *args):
        """
        _set_z(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_z(self, *args)

    z = property(                                                                lambda self: self._get_z() if op_uses_z(self.op) else None,                    lambda self, v:                                                              self._ensure_cond(op_uses_z(self.op),"op_uses_z(self.op)")                                           and self._ensure_no_obj(self._get_z(),"z", True)                  and self._acquire_ownership(v, True)                                  and self._set_z(v))
    def _get_ptrsize(self, *args):
        """
        _get_ptrsize(self) -> int
        """
        return _ida_hexrays.cexpr_t__get_ptrsize(self, *args)

    def _set_ptrsize(self, *args):
        """
        _set_ptrsize(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_ptrsize(self, *args)

    ptrsize = property(                                                                lambda self: self._get_ptrsize() if (self.op == cot_ptr or self.op == cot_memptr) else 0,                    lambda self, v:                                                              self._ensure_cond((self.op == cot_ptr or self.op == cot_memptr),"(self.op == cot_ptr or self.op == cot_memptr)")                                           and self._ensure_no_obj(self._get_ptrsize(),"ptrsize", False)                  and self._acquire_ownership(v, False)                                  and self._set_ptrsize(v))
    def _get_insn(self, *args):
        """
        _get_insn(self) -> cinsn_t
        """
        return _ida_hexrays.cexpr_t__get_insn(self, *args)

    def _set_insn(self, *args):
        """
        _set_insn(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_insn(self, *args)

    insn = property(                                                                lambda self: self._get_insn() if self.op == cot_insn else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_insn,"self.op == cot_insn")                                           and self._ensure_no_obj(self._get_insn(),"insn", True)                  and self._acquire_ownership(v, True)                                  and self._set_insn(v))
    def _get_helper(self, *args):
        """
        _get_helper(self) -> char *
        """
        return _ida_hexrays.cexpr_t__get_helper(self, *args)

    def _set_helper(self, *args):
        """
        _set_helper(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_helper(self, *args)

    helper = property(                                                                lambda self: self._get_helper() if self.op == cot_helper else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_helper,"self.op == cot_helper")                                           and self._ensure_no_obj(self._get_helper(),"helper", False)                  and self._acquire_ownership(v, False)                                  and self._set_helper(v))
    def _get_string(self, *args):
        """
        _get_string(self) -> char *
        """
        return _ida_hexrays.cexpr_t__get_string(self, *args)

    def _set_string(self, *args):
        """
        _set_string(self, _v)
        """
        return _ida_hexrays.cexpr_t__set_string(self, *args)

    string = property(                                                                lambda self: self._get_string() if self.op == cot_str else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cot_str,"self.op == cot_str")                                           and self._ensure_no_obj(self._get_string(),"string", False)                  and self._acquire_ownership(v, False)                                  and self._set_string(v))
cexpr_t_swigregister = _ida_hexrays.cexpr_t_swigregister
cexpr_t_swigregister(cexpr_t)
EXFL_CPADONE = _ida_hexrays.EXFL_CPADONE
"""
pointer arithmetic correction done
"""
EXFL_LVALUE = _ida_hexrays.EXFL_LVALUE
"""
expression is lvalue even if it doesn't look like it
"""
EXFL_FPOP = _ida_hexrays.EXFL_FPOP
"""
floating point operation
"""
EXFL_ALONE = _ida_hexrays.EXFL_ALONE
"""
standalone helper
"""
EXFL_CSTR = _ida_hexrays.EXFL_CSTR
"""
string literal
"""
EXFL_PARTIAL = _ida_hexrays.EXFL_PARTIAL
"""
type of the expression is considered partial
"""
EXFL_UNDEF = _ida_hexrays.EXFL_UNDEF
"""
expression uses undefined value
"""
EXFL_JUMPOUT = _ida_hexrays.EXFL_JUMPOUT
"""
jump out-of-function
"""
EXFL_VFTABLE = _ida_hexrays.EXFL_VFTABLE
"""
is ptr to vftable (used for cot_memptr, cot_memref)
"""
EXFL_ALL = _ida_hexrays.EXFL_ALL
"""
all currently defined bits
"""

class ceinsn_t(object):
    """
    Proxy of C++ ceinsn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    expr = _swig_property(_ida_hexrays.ceinsn_t_expr_get, _ida_hexrays.ceinsn_t_expr_set)
    def __init__(self, *args):
        """
        __init__(self) -> ceinsn_t
        """
        this = _ida_hexrays.new_ceinsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ceinsn_t
    __del__ = lambda self : None;
ceinsn_t_swigregister = _ida_hexrays.ceinsn_t_swigregister
ceinsn_t_swigregister(ceinsn_t)

CALC_CURLY_BRACES = _ida_hexrays.CALC_CURLY_BRACES
NO_CURLY_BRACES = _ida_hexrays.NO_CURLY_BRACES
USE_CURLY_BRACES = _ida_hexrays.USE_CURLY_BRACES
class cif_t(ceinsn_t):
    """
    Proxy of C++ cif_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ithen = _swig_property(_ida_hexrays.cif_t_ithen_get, _ida_hexrays.cif_t_ithen_set)
    ielse = _swig_property(_ida_hexrays.cif_t_ielse_get, _ida_hexrays.cif_t_ielse_set)
    def __init__(self, *args):
        """
        __init__(self) -> cif_t
        __init__(self, r) -> cif_t
        """
        this = _ida_hexrays.new_cif_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, r) -> cif_t
        """
        return _ida_hexrays.cif_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cif_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cif_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cif_t
    __del__ = lambda self : None;
    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cif_t_cleanup(self, *args)

cif_t_swigregister = _ida_hexrays.cif_t_swigregister
cif_t_swigregister(cif_t)

class cloop_t(ceinsn_t):
    """
    Proxy of C++ cloop_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    body = _swig_property(_ida_hexrays.cloop_t_body_get, _ida_hexrays.cloop_t_body_set)
    def __init__(self, *args):
        """
        __init__(self) -> cloop_t
        __init__(self, b) -> cloop_t
        __init__(self, r) -> cloop_t
        """
        this = _ida_hexrays.new_cloop_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def assign(self, *args):
        """
        assign(self, r) -> cloop_t
        """
        return _ida_hexrays.cloop_t_assign(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cloop_t
    __del__ = lambda self : None;
    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cloop_t_cleanup(self, *args)

cloop_t_swigregister = _ida_hexrays.cloop_t_swigregister
cloop_t_swigregister(cloop_t)

class cfor_t(cloop_t):
    """
    Proxy of C++ cfor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    init = _swig_property(_ida_hexrays.cfor_t_init_get, _ida_hexrays.cfor_t_init_set)
    step = _swig_property(_ida_hexrays.cfor_t_step_get, _ida_hexrays.cfor_t_step_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cfor_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cfor_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cfor_t
        """
        this = _ida_hexrays.new_cfor_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cfor_t
    __del__ = lambda self : None;
cfor_t_swigregister = _ida_hexrays.cfor_t_swigregister
cfor_t_swigregister(cfor_t)

class cwhile_t(cloop_t):
    """
    Proxy of C++ cwhile_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cwhile_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cwhile_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cwhile_t
        """
        this = _ida_hexrays.new_cwhile_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cwhile_t
    __del__ = lambda self : None;
cwhile_t_swigregister = _ida_hexrays.cwhile_t_swigregister
cwhile_t_swigregister(cwhile_t)

class cdo_t(cloop_t):
    """
    Proxy of C++ cdo_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cdo_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cdo_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cdo_t
        """
        this = _ida_hexrays.new_cdo_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cdo_t
    __del__ = lambda self : None;
cdo_t_swigregister = _ida_hexrays.cdo_t_swigregister
cdo_t_swigregister(cdo_t)

class creturn_t(ceinsn_t):
    """
    Proxy of C++ creturn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.creturn_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.creturn_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> creturn_t
        """
        this = _ida_hexrays.new_creturn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_creturn_t
    __del__ = lambda self : None;
creturn_t_swigregister = _ida_hexrays.creturn_t_swigregister
creturn_t_swigregister(creturn_t)

class cgoto_t(object):
    """
    Proxy of C++ cgoto_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    label_num = _swig_property(_ida_hexrays.cgoto_t_label_num_get, _ida_hexrays.cgoto_t_label_num_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cgoto_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cgoto_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cgoto_t
        """
        this = _ida_hexrays.new_cgoto_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cgoto_t
    __del__ = lambda self : None;
cgoto_t_swigregister = _ida_hexrays.cgoto_t_swigregister
cgoto_t_swigregister(cgoto_t)

class casm_t(object):
    """
    Proxy of C++ casm_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self, ea) -> casm_t
        __init__(self, r) -> casm_t
        """
        this = _ida_hexrays.new_casm_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.casm_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.casm_t_compare(self, *args)

    def one_insn(self, *args):
        """
        one_insn(self) -> bool
        """
        return _ida_hexrays.casm_t_one_insn(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_casm_t
    __del__ = lambda self : None;
casm_t_swigregister = _ida_hexrays.casm_t_swigregister
casm_t_swigregister(casm_t)

class cinsn_t(citem_t):
    """
    Proxy of C++ cinsn_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args):
        """
        __init__(self) -> cinsn_t
        __init__(self, r) -> cinsn_t
        """
        this = _ida_hexrays.new_cinsn_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args):
        """
        swap(self, r)
        """
        return _ida_hexrays.cinsn_t_swap(self, *args)

    def assign(self, *args):
        """
        assign(self, r) -> cinsn_t
        """
        return _ida_hexrays.cinsn_t_assign(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cinsn_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cinsn_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_cinsn_t
    __del__ = lambda self : None;
    def _replace_by(self, *args):
        """
        _replace_by(self, r)
        """
        return _ida_hexrays.cinsn_t__replace_by(self, *args)

    def cleanup(self, *args):
        """
        cleanup(self)
        """
        return _ida_hexrays.cinsn_t_cleanup(self, *args)

    def zero(self, *args):
        """
        zero(self)
        """
        return _ida_hexrays.cinsn_t_zero(self, *args)

    def new_insn(self, *args):
        """
        new_insn(self, insn_ea) -> cinsn_t
        """
        return _ida_hexrays.cinsn_t_new_insn(self, *args)

    def create_if(self, *args):
        """
        create_if(self, cnd) -> cif_t
        """
        return _ida_hexrays.cinsn_t_create_if(self, *args)

    def _print(self, *args):
        """
        _print(self, indent, vp, use_curly=CALC_CURLY_BRACES)
        """
        return _ida_hexrays.cinsn_t__print(self, *args)

    def print1(self, *args):
        """
        print1(self, func)
        """
        return _ida_hexrays.cinsn_t_print1(self, *args)

    def is_ordinary_flow(self, *args):
        """
        is_ordinary_flow(self) -> bool
        """
        return _ida_hexrays.cinsn_t_is_ordinary_flow(self, *args)

    def contains_insn(self, *args):
        """
        contains_insn(self, type, times=1) -> bool
        """
        return _ida_hexrays.cinsn_t_contains_insn(self, *args)

    def collect_free_breaks(self, *args):
        """
        collect_free_breaks(self, breaks) -> bool
        """
        return _ida_hexrays.cinsn_t_collect_free_breaks(self, *args)

    def collect_free_continues(self, *args):
        """
        collect_free_continues(self, continues) -> bool
        """
        return _ida_hexrays.cinsn_t_collect_free_continues(self, *args)

    def contains_free_break(self, *args):
        """
        contains_free_break(self) -> bool
        """
        return _ida_hexrays.cinsn_t_contains_free_break(self, *args)

    def contains_free_continue(self, *args):
        """
        contains_free_continue(self) -> bool
        """
        return _ida_hexrays.cinsn_t_contains_free_continue(self, *args)

    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.cinsn_t__deregister(self, *args)

    def _register(self, *args):
        """
        _register(self)
        """
        return _ida_hexrays.cinsn_t__register(self, *args)

    def _get_cblock(self, *args):
        """
        _get_cblock(self) -> cblock_t
        """
        return _ida_hexrays.cinsn_t__get_cblock(self, *args)

    def _set_cblock(self, *args):
        """
        _set_cblock(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cblock(self, *args)

    cblock = property(                                                                lambda self: self._get_cblock() if self.op == cit_block else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_block,"self.op == cit_block")                                           and self._ensure_no_obj(self._get_cblock(),"cblock", True)                  and self._acquire_ownership(v, True)                                  and self._set_cblock(v))
    def _get_cexpr(self, *args):
        """
        _get_cexpr(self) -> cexpr_t
        """
        return _ida_hexrays.cinsn_t__get_cexpr(self, *args)

    def _set_cexpr(self, *args):
        """
        _set_cexpr(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cexpr(self, *args)

    cexpr = property(                                                                lambda self: self._get_cexpr() if self.op == cit_expr else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_expr,"self.op == cit_expr")                                           and self._ensure_no_obj(self._get_cexpr(),"cexpr", True)                  and self._acquire_ownership(v, True)                                  and self._set_cexpr(v))
    def _get_cif(self, *args):
        """
        _get_cif(self) -> cif_t
        """
        return _ida_hexrays.cinsn_t__get_cif(self, *args)

    def _set_cif(self, *args):
        """
        _set_cif(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cif(self, *args)

    cif = property(                                                                lambda self: self._get_cif() if self.op == cit_if else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_if,"self.op == cit_if")                                           and self._ensure_no_obj(self._get_cif(),"cif", True)                  and self._acquire_ownership(v, True)                                  and self._set_cif(v))
    def _get_cfor(self, *args):
        """
        _get_cfor(self) -> cfor_t
        """
        return _ida_hexrays.cinsn_t__get_cfor(self, *args)

    def _set_cfor(self, *args):
        """
        _set_cfor(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cfor(self, *args)

    cfor = property(                                                                lambda self: self._get_cfor() if self.op == cit_for else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_for,"self.op == cit_for")                                           and self._ensure_no_obj(self._get_cfor(),"cfor", True)                  and self._acquire_ownership(v, True)                                  and self._set_cfor(v))
    def _get_cwhile(self, *args):
        """
        _get_cwhile(self) -> cwhile_t
        """
        return _ida_hexrays.cinsn_t__get_cwhile(self, *args)

    def _set_cwhile(self, *args):
        """
        _set_cwhile(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cwhile(self, *args)

    cwhile = property(                                                                lambda self: self._get_cwhile() if self.op == cit_while else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_while,"self.op == cit_while")                                           and self._ensure_no_obj(self._get_cwhile(),"cwhile", True)                  and self._acquire_ownership(v, True)                                  and self._set_cwhile(v))
    def _get_cdo(self, *args):
        """
        _get_cdo(self) -> cdo_t
        """
        return _ida_hexrays.cinsn_t__get_cdo(self, *args)

    def _set_cdo(self, *args):
        """
        _set_cdo(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cdo(self, *args)

    cdo = property(                                                                lambda self: self._get_cdo() if self.op == cit_do else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_do,"self.op == cit_do")                                           and self._ensure_no_obj(self._get_cdo(),"cdo", True)                  and self._acquire_ownership(v, True)                                  and self._set_cdo(v))
    def _get_cswitch(self, *args):
        """
        _get_cswitch(self) -> cswitch_t
        """
        return _ida_hexrays.cinsn_t__get_cswitch(self, *args)

    def _set_cswitch(self, *args):
        """
        _set_cswitch(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cswitch(self, *args)

    cswitch = property(                                                                lambda self: self._get_cswitch() if self.op == cit_switch else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_switch,"self.op == cit_switch")                                           and self._ensure_no_obj(self._get_cswitch(),"cswitch", True)                  and self._acquire_ownership(v, True)                                  and self._set_cswitch(v))
    def _get_creturn(self, *args):
        """
        _get_creturn(self) -> creturn_t
        """
        return _ida_hexrays.cinsn_t__get_creturn(self, *args)

    def _set_creturn(self, *args):
        """
        _set_creturn(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_creturn(self, *args)

    creturn = property(                                                                lambda self: self._get_creturn() if self.op == cit_return else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_return,"self.op == cit_return")                                           and self._ensure_no_obj(self._get_creturn(),"creturn", True)                  and self._acquire_ownership(v, True)                                  and self._set_creturn(v))
    def _get_cgoto(self, *args):
        """
        _get_cgoto(self) -> cgoto_t
        """
        return _ida_hexrays.cinsn_t__get_cgoto(self, *args)

    def _set_cgoto(self, *args):
        """
        _set_cgoto(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_cgoto(self, *args)

    cgoto = property(                                                                lambda self: self._get_cgoto() if self.op == cit_goto else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_goto,"self.op == cit_goto")                                           and self._ensure_no_obj(self._get_cgoto(),"cgoto", True)                  and self._acquire_ownership(v, True)                                  and self._set_cgoto(v))
    def _get_casm(self, *args):
        """
        _get_casm(self) -> casm_t
        """
        return _ida_hexrays.cinsn_t__get_casm(self, *args)

    def _set_casm(self, *args):
        """
        _set_casm(self, _v)
        """
        return _ida_hexrays.cinsn_t__set_casm(self, *args)

    casm = property(                                                                lambda self: self._get_casm() if self.op == cit_asm else None,                    lambda self, v:                                                              self._ensure_cond(self.op == cit_asm,"self.op == cit_asm")                                           and self._ensure_no_obj(self._get_casm(),"casm", True)                  and self._acquire_ownership(v, True)                                  and self._set_casm(v))
    def insn_is_epilog(*args):
        """
        insn_is_epilog(insn) -> bool
        """
        return _ida_hexrays.cinsn_t_insn_is_epilog(*args)

    insn_is_epilog = staticmethod(insn_is_epilog)
    def is_epilog(self):
        return cinsn_t.insn_is_epilog(self)

cinsn_t_swigregister = _ida_hexrays.cinsn_t_swigregister
cinsn_t_swigregister(cinsn_t)

def cinsn_t_insn_is_epilog(*args):
  """
  cinsn_t_insn_is_epilog(insn) -> bool
  """
  return _ida_hexrays.cinsn_t_insn_is_epilog(*args)

class cblock_t(qlist_cinsn_t):
    """
    Proxy of C++ cblock_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cblock_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cblock_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cblock_t
        """
        this = _ida_hexrays.new_cblock_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cblock_t
    __del__ = lambda self : None;
    def _deregister(self, *args):
        """
        _deregister(self)
        """
        return _ida_hexrays.cblock_t__deregister(self, *args)

cblock_t_swigregister = _ida_hexrays.cblock_t_swigregister
cblock_t_swigregister(cblock_t)

class carg_t(cexpr_t):
    """
    Proxy of C++ carg_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    is_vararg = _swig_property(_ida_hexrays.carg_t_is_vararg_get, _ida_hexrays.carg_t_is_vararg_set)
    formal_type = _swig_property(_ida_hexrays.carg_t_formal_type_get, _ida_hexrays.carg_t_formal_type_set)
    def consume_cexpr(self, *args):
        """
        consume_cexpr(self, e)
        """
        return _ida_hexrays.carg_t_consume_cexpr(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> carg_t
        """
        this = _ida_hexrays.new_carg_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.carg_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.carg_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_carg_t
    __del__ = lambda self : None;
carg_t_swigregister = _ida_hexrays.carg_t_swigregister
carg_t_swigregister(carg_t)

class carglist_t(qvector_carg_t):
    """
    Proxy of C++ carglist_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    functype = _swig_property(_ida_hexrays.carglist_t_functype_get, _ida_hexrays.carglist_t_functype_set)
    flags = _swig_property(_ida_hexrays.carglist_t_flags_get, _ida_hexrays.carglist_t_flags_set)
    def __init__(self, *args):
        """
        __init__(self) -> carglist_t
        __init__(self, ftype, fl=0) -> carglist_t
        """
        this = _ida_hexrays.new_carglist_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.carglist_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.carglist_t_compare(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_carglist_t
    __del__ = lambda self : None;
carglist_t_swigregister = _ida_hexrays.carglist_t_swigregister
carglist_t_swigregister(carglist_t)
CFL_FINAL = _ida_hexrays.CFL_FINAL
"""
call type is final, should not be changed
"""
CFL_HELPER = _ida_hexrays.CFL_HELPER
"""
created from a decompiler helper function
"""

class ccase_t(cinsn_t):
    """
    Proxy of C++ ccase_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    values = _swig_property(_ida_hexrays.ccase_t_values_get, _ida_hexrays.ccase_t_values_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ccase_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ccase_t_compare(self, *args)

    def size(self, *args):
        """
        size(self) -> size_t
        """
        return _ida_hexrays.ccase_t_size(self, *args)

    def value(self, *args):
        """
        value(self, i) -> uint64 const &
        """
        return _ida_hexrays.ccase_t_value(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> ccase_t
        """
        this = _ida_hexrays.new_ccase_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ccase_t
    __del__ = lambda self : None;
ccase_t_swigregister = _ida_hexrays.ccase_t_swigregister
ccase_t_swigregister(ccase_t)

class ccases_t(qvector_ccase_t):
    """
    Proxy of C++ ccases_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ccases_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ccases_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> ccases_t
        """
        this = _ida_hexrays.new_ccases_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ccases_t
    __del__ = lambda self : None;
ccases_t_swigregister = _ida_hexrays.ccases_t_swigregister
ccases_t_swigregister(ccases_t)

class cswitch_t(ceinsn_t):
    """
    Proxy of C++ cswitch_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mvnf = _swig_property(_ida_hexrays.cswitch_t_mvnf_get, _ida_hexrays.cswitch_t_mvnf_set)
    cases = _swig_property(_ida_hexrays.cswitch_t_cases_get, _ida_hexrays.cswitch_t_cases_set)
    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.cswitch_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.cswitch_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> cswitch_t
        """
        this = _ida_hexrays.new_cswitch_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_cswitch_t
    __del__ = lambda self : None;
cswitch_t_swigregister = _ida_hexrays.cswitch_t_swigregister
cswitch_t_swigregister(cswitch_t)

class ctree_anchor_t(object):
    """
    Proxy of C++ ctree_anchor_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    value = _swig_property(_ida_hexrays.ctree_anchor_t_value_get, _ida_hexrays.ctree_anchor_t_value_set)
    def __init__(self, *args):
        """
        __init__(self) -> ctree_anchor_t
        """
        this = _ida_hexrays.new_ctree_anchor_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_index(self, *args):
        """
        get_index(self) -> int
        """
        return _ida_hexrays.ctree_anchor_t_get_index(self, *args)

    def get_itp(self, *args):
        """
        get_itp(self) -> item_preciser_t
        """
        return _ida_hexrays.ctree_anchor_t_get_itp(self, *args)

    def is_valid_anchor(self, *args):
        """
        is_valid_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_valid_anchor(self, *args)

    def is_citem_anchor(self, *args):
        """
        is_citem_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_citem_anchor(self, *args)

    def is_lvar_anchor(self, *args):
        """
        is_lvar_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_lvar_anchor(self, *args)

    def is_itp_anchor(self, *args):
        """
        is_itp_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_itp_anchor(self, *args)

    def is_blkcmt_anchor(self, *args):
        """
        is_blkcmt_anchor(self) -> bool
        """
        return _ida_hexrays.ctree_anchor_t_is_blkcmt_anchor(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_ctree_anchor_t
    __del__ = lambda self : None;
ctree_anchor_t_swigregister = _ida_hexrays.ctree_anchor_t_swigregister
ctree_anchor_t_swigregister(ctree_anchor_t)
ANCHOR_INDEX = _ida_hexrays.ANCHOR_INDEX
ANCHOR_MASK = _ida_hexrays.ANCHOR_MASK
ANCHOR_CITEM = _ida_hexrays.ANCHOR_CITEM
"""
c-tree item
"""
ANCHOR_LVAR = _ida_hexrays.ANCHOR_LVAR
"""
declaration of local variable
"""
ANCHOR_ITP = _ida_hexrays.ANCHOR_ITP
"""
item type preciser
"""
ANCHOR_BLKCMT = _ida_hexrays.ANCHOR_BLKCMT
"""
block comment (for ctree items)
"""

VDI_NONE = _ida_hexrays.VDI_NONE
VDI_EXPR = _ida_hexrays.VDI_EXPR
VDI_LVAR = _ida_hexrays.VDI_LVAR
VDI_FUNC = _ida_hexrays.VDI_FUNC
VDI_TAIL = _ida_hexrays.VDI_TAIL
class ctree_item_t(object):
    """
    Proxy of C++ ctree_item_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    citype = _swig_property(_ida_hexrays.ctree_item_t_citype_get, _ida_hexrays.ctree_item_t_citype_set)
    def __init__(self, *args):
        """
        __init__(self) -> ctree_item_t
        """
        this = _ida_hexrays.new_ctree_item_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def get_memptr(self, *args):
        """
        get_memptr(self, p_sptr=None) -> member_t *
        """
        return _ida_hexrays.ctree_item_t_get_memptr(self, *args)

    def get_lvar(self, *args):
        """
        get_lvar(self) -> lvar_t
        """
        return _ida_hexrays.ctree_item_t_get_lvar(self, *args)

    def get_ea(self, *args):
        """
        get_ea(self) -> ea_t
        """
        return _ida_hexrays.ctree_item_t_get_ea(self, *args)

    def get_label_num(self, *args):
        """
        get_label_num(self, gln_flags) -> int
        """
        return _ida_hexrays.ctree_item_t_get_label_num(self, *args)

    def is_citem(self, *args):
        """
        is_citem(self) -> bool
        """
        return _ida_hexrays.ctree_item_t_is_citem(self, *args)

    def _get_it(self, *args):
        """
        _get_it(self) -> citem_t
        """
        return _ida_hexrays.ctree_item_t__get_it(self, *args)

    it = property(lambda self: self._get_it())
    def _get_e(self, *args):
        """
        _get_e(self) -> cexpr_t
        """
        return _ida_hexrays.ctree_item_t__get_e(self, *args)

    e = property(lambda self: self._get_e())
    def _get_i(self, *args):
        """
        _get_i(self) -> cinsn_t
        """
        return _ida_hexrays.ctree_item_t__get_i(self, *args)

    i = property(lambda self: self._get_i())
    def _get_l(self, *args):
        """
        _get_l(self) -> lvar_t
        """
        return _ida_hexrays.ctree_item_t__get_l(self, *args)

    l = property(lambda self: self._get_l())
    def _get_f(self, *args):
        """
        _get_f(self) -> cfunc_t
        """
        return _ida_hexrays.ctree_item_t__get_f(self, *args)

    f = property(lambda self: self._get_f())
    loc = _swig_property(_ida_hexrays.ctree_item_t_loc_get)
    __swig_destroy__ = _ida_hexrays.delete_ctree_item_t
    __del__ = lambda self : None;
ctree_item_t_swigregister = _ida_hexrays.ctree_item_t_swigregister
ctree_item_t_swigregister(ctree_item_t)
GLN_CURRENT = _ida_hexrays.GLN_CURRENT
"""
get label of the current item
"""
GLN_GOTO_TARGET = _ida_hexrays.GLN_GOTO_TARGET
"""
get goto target
"""
GLN_ALL = _ida_hexrays.GLN_ALL
"""
get both
"""

FORBID_UNUSED_LABELS = _ida_hexrays.FORBID_UNUSED_LABELS
ALLOW_UNUSED_LABELS = _ida_hexrays.ALLOW_UNUSED_LABELS

def _ll_lnot(*args):
  """
  _ll_lnot(e) -> cexpr_t
  """
  return _ida_hexrays._ll_lnot(*args)

def _ll_new_block(*args):
  """
  _ll_new_block() -> cinsn_t
  """
  return _ida_hexrays._ll_new_block(*args)

def _ll_create_helper(*args):
  """
  _ll_create_helper(standalone, type, format) -> cexpr_t
  """
  return _ida_hexrays._ll_create_helper(*args)

def _ll_call_helper(*args):
  """
  _ll_call_helper(rettype, args, format) -> cexpr_t
  """
  return _ida_hexrays._ll_call_helper(*args)

def _ll_make_num(*args):
  """
  _ll_make_num(n, func=None, ea=BADADDR, opnum=0, sign=no_sign, size=0) -> cexpr_t
  """
  return _ida_hexrays._ll_make_num(*args)

def _ll_make_ref(*args):
  """
  _ll_make_ref(e) -> cexpr_t
  """
  return _ida_hexrays._ll_make_ref(*args)

def _ll_dereference(*args):
  """
  _ll_dereference(e, ptrsize, is_flt=False) -> cexpr_t
  """
  return _ida_hexrays._ll_dereference(*args)

def save_user_labels(*args):
  """
  save_user_labels(func_ea, user_labels)


  Save user defined labels into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param user_labels: collection of user defined labels (C++: const
                      user_labels_t *)
  """
  return _ida_hexrays.save_user_labels(*args)

def save_user_cmts(*args):
  """
  save_user_cmts(func_ea, user_cmts)


  Save user defined comments into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param user_cmts: collection of user defined comments (C++: const
                    user_cmts_t *)
  """
  return _ida_hexrays.save_user_cmts(*args)

def save_user_numforms(*args):
  """
  save_user_numforms(func_ea, numforms)


  Save user defined number formats into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param numforms: collection of user defined comments (C++: const
                   user_numforms_t *)
  """
  return _ida_hexrays.save_user_numforms(*args)

def save_user_iflags(*args):
  """
  save_user_iflags(func_ea, iflags)


  Save user defined citem iflags into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param iflags: collection of user defined citem iflags (C++: const
                 user_iflags_t *)
  """
  return _ida_hexrays.save_user_iflags(*args)

def save_user_unions(*args):
  """
  save_user_unions(func_ea, unions)


  Save user defined union field selections into the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @param unions: collection of union field selections (C++: const
                 user_unions_t *)
  """
  return _ida_hexrays.save_user_unions(*args)

def restore_user_labels(*args):
  """
  restore_user_labels(func_ea) -> user_labels_t


  Restore user defined labels from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined labels. The returned object must
           be deleted by the caller using delete_user_labels()
  """
  return _ida_hexrays.restore_user_labels(*args)

def restore_user_cmts(*args):
  """
  restore_user_cmts(func_ea) -> user_cmts_t


  Restore user defined comments from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined comments. The returned object must
           be deleted by the caller using delete_user_cmts()
  """
  return _ida_hexrays.restore_user_cmts(*args)

def restore_user_numforms(*args):
  """
  restore_user_numforms(func_ea) -> user_numforms_t


  Restore user defined number formats from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined number formats. The returned
           object must be deleted by the caller using
           delete_user_numforms()
  """
  return _ida_hexrays.restore_user_numforms(*args)

def restore_user_iflags(*args):
  """
  restore_user_iflags(func_ea) -> user_iflags_t


  Restore user defined citem iflags from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of user defined iflags. The returned object must
           be deleted by the caller using delete_user_iflags()
  """
  return _ida_hexrays.restore_user_iflags(*args)

def restore_user_unions(*args):
  """
  restore_user_unions(func_ea) -> user_unions_t


  Restore user defined union field selections from the database.
  
  @param func_ea: the entry address of the function (C++: ea_t)
  @return: collection of union field selections The returned object must
           be deleted by the caller using delete_user_unions()
  """
  return _ida_hexrays.restore_user_unions(*args)
class cfunc_t(object):
    """
    Proxy of C++ cfunc_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    entry_ea = _swig_property(_ida_hexrays.cfunc_t_entry_ea_get, _ida_hexrays.cfunc_t_entry_ea_set)
    mba = _swig_property(_ida_hexrays.cfunc_t_mba_get, _ida_hexrays.cfunc_t_mba_set)
    body = _swig_property(_ida_hexrays.cfunc_t_body_get, _ida_hexrays.cfunc_t_body_set)
    argidx = _swig_property(_ida_hexrays.cfunc_t_argidx_get)
    maturity = _swig_property(_ida_hexrays.cfunc_t_maturity_get, _ida_hexrays.cfunc_t_maturity_set)
    user_labels = _swig_property(_ida_hexrays.cfunc_t_user_labels_get, _ida_hexrays.cfunc_t_user_labels_set)
    user_cmts = _swig_property(_ida_hexrays.cfunc_t_user_cmts_get, _ida_hexrays.cfunc_t_user_cmts_set)
    numforms = _swig_property(_ida_hexrays.cfunc_t_numforms_get, _ida_hexrays.cfunc_t_numforms_set)
    user_iflags = _swig_property(_ida_hexrays.cfunc_t_user_iflags_get, _ida_hexrays.cfunc_t_user_iflags_set)
    user_unions = _swig_property(_ida_hexrays.cfunc_t_user_unions_get, _ida_hexrays.cfunc_t_user_unions_set)
    refcnt = _swig_property(_ida_hexrays.cfunc_t_refcnt_get, _ida_hexrays.cfunc_t_refcnt_set)
    statebits = _swig_property(_ida_hexrays.cfunc_t_statebits_get, _ida_hexrays.cfunc_t_statebits_set)
    hdrlines = _swig_property(_ida_hexrays.cfunc_t_hdrlines_get, _ida_hexrays.cfunc_t_hdrlines_set)
    treeitems = _swig_property(_ida_hexrays.cfunc_t_treeitems_get, _ida_hexrays.cfunc_t_treeitems_set)
    __swig_destroy__ = _ida_hexrays.delete_cfunc_t
    __del__ = lambda self : None;
    def release(self, *args):
        """
        release(self)
        """
        return _ida_hexrays.cfunc_t_release(self, *args)

    def build_c_tree(self, *args):
        """
        build_c_tree(self)
        """
        return _ida_hexrays.cfunc_t_build_c_tree(self, *args)

    def verify(self, *args):
        """
        verify(self, aul, even_without_debugger)
        """
        return _ida_hexrays.cfunc_t_verify(self, *args)

    def print_dcl(self, *args):
        """
        print_dcl(self)
        """
        return _ida_hexrays.cfunc_t_print_dcl(self, *args)

    def print_func(self, *args):
        """
        print_func(self, vp)
        """
        return _ida_hexrays.cfunc_t_print_func(self, *args)

    def get_func_type(self, *args):
        """
        get_func_type(self, type) -> bool
        """
        return _ida_hexrays.cfunc_t_get_func_type(self, *args)

    def get_lvars(self, *args):
        """
        get_lvars(self) -> lvars_t
        """
        return _ida_hexrays.cfunc_t_get_lvars(self, *args)

    def get_stkoff_delta(self, *args):
        """
        get_stkoff_delta(self) -> sval_t
        """
        return _ida_hexrays.cfunc_t_get_stkoff_delta(self, *args)

    def find_label(self, *args):
        """
        find_label(self, label) -> citem_t
        """
        return _ida_hexrays.cfunc_t_find_label(self, *args)

    def remove_unused_labels(self, *args):
        """
        remove_unused_labels(self)
        """
        return _ida_hexrays.cfunc_t_remove_unused_labels(self, *args)

    def get_user_cmt(self, *args):
        """
        get_user_cmt(self, loc, rt) -> char const *
        """
        return _ida_hexrays.cfunc_t_get_user_cmt(self, *args)

    def set_user_cmt(self, *args):
        """
        set_user_cmt(self, loc, cmt)
        """
        return _ida_hexrays.cfunc_t_set_user_cmt(self, *args)

    def get_user_iflags(self, *args):
        """
        get_user_iflags(self, loc) -> int32
        """
        return _ida_hexrays.cfunc_t_get_user_iflags(self, *args)

    def set_user_iflags(self, *args):
        """
        set_user_iflags(self, loc, iflags)
        """
        return _ida_hexrays.cfunc_t_set_user_iflags(self, *args)

    def has_orphan_cmts(self, *args):
        """
        has_orphan_cmts(self) -> bool
        """
        return _ida_hexrays.cfunc_t_has_orphan_cmts(self, *args)

    def del_orphan_cmts(self, *args):
        """
        del_orphan_cmts(self) -> int
        """
        return _ida_hexrays.cfunc_t_del_orphan_cmts(self, *args)

    def get_user_union_selection(self, *args):
        """
        get_user_union_selection(self, ea, path) -> bool
        """
        return _ida_hexrays.cfunc_t_get_user_union_selection(self, *args)

    def set_user_union_selection(self, *args):
        """
        set_user_union_selection(self, ea, path)
        """
        return _ida_hexrays.cfunc_t_set_user_union_selection(self, *args)

    def save_user_labels(self, *args):
        """
        save_user_labels(self)
        """
        return _ida_hexrays.cfunc_t_save_user_labels(self, *args)

    def save_user_cmts(self, *args):
        """
        save_user_cmts(self)
        """
        return _ida_hexrays.cfunc_t_save_user_cmts(self, *args)

    def save_user_numforms(self, *args):
        """
        save_user_numforms(self)
        """
        return _ida_hexrays.cfunc_t_save_user_numforms(self, *args)

    def save_user_iflags(self, *args):
        """
        save_user_iflags(self)
        """
        return _ida_hexrays.cfunc_t_save_user_iflags(self, *args)

    def save_user_unions(self, *args):
        """
        save_user_unions(self)
        """
        return _ida_hexrays.cfunc_t_save_user_unions(self, *args)

    def get_line_item(self, *args):
        """
        get_line_item(self, line, x, is_ctree_line, phead, pitem, ptail) -> bool
        """
        return _ida_hexrays.cfunc_t_get_line_item(self, *args)

    def get_warnings(self, *args):
        """
        get_warnings(self) -> hexwarns_t
        """
        return _ida_hexrays.cfunc_t_get_warnings(self, *args)

    def get_eamap(self, *args):
        """
        get_eamap(self) -> eamap_t
        """
        return _ida_hexrays.cfunc_t_get_eamap(self, *args)

    def get_boundaries(self, *args):
        """
        get_boundaries(self) -> boundaries_t
        """
        return _ida_hexrays.cfunc_t_get_boundaries(self, *args)

    def get_pseudocode(self, *args):
        """
        get_pseudocode(self) -> strvec_t const &
        """
        return _ida_hexrays.cfunc_t_get_pseudocode(self, *args)

    def gather_derefs(self, *args):
        """
        gather_derefs(self, ci, udm=None) -> bool
        """
        return _ida_hexrays.cfunc_t_gather_derefs(self, *args)

    def find_item_coords(self, *args):
        """
        find_item_coords(self, item, px, py) -> bool
        find_item_coords(self, item) -> PyObject *
        """
        return _ida_hexrays.cfunc_t_find_item_coords(self, *args)

    def __str__(self, *args):
        """
        __str__(self) -> qstring
        """
        return _ida_hexrays.cfunc_t___str__(self, *args)

cfunc_t_swigregister = _ida_hexrays.cfunc_t_swigregister
cfunc_t_swigregister(cfunc_t)
CIT_COLLAPSED = _ida_hexrays.CIT_COLLAPSED
"""
display element in collapsed form
"""
CFS_BOUNDS = _ida_hexrays.CFS_BOUNDS
"""
'eamap' and 'boundaries' are ready
"""
CFS_TEXT = _ida_hexrays.CFS_TEXT
"""
'sv' is ready (and hdrlines)
"""
CFS_LVARS_HIDDEN = _ida_hexrays.CFS_LVARS_HIDDEN
"""
local variable definitions are collapsed
"""

DECOMP_NO_WAIT = _ida_hexrays.DECOMP_NO_WAIT
"""
do not display waitbox
"""
DECOMP_NO_CACHE = _ida_hexrays.DECOMP_NO_CACHE
"""
do not use decompilation cache
"""
DECOMP_NO_FRAME = _ida_hexrays.DECOMP_NO_FRAME
"""
do not use function frame info (only snippet mode)
"""
DECOMP_WARNINGS = _ida_hexrays.DECOMP_WARNINGS
"""
display warnings in the output window
"""

def decompile(*args):
  """
  decompile(pfn, hf, flags=0) -> cfuncptr_t


  Decompile a snippet or a function.
  
  @param hf: extended error information (if failed) (C++:
             hexrays_failure_t  *)
  @param flags: bitwise combination of  decompile() flags ... bits (C++:
                int)
  @return: pointer to the decompilation result (a reference counted
           pointer). NULL if failed.
  """
  return _ida_hexrays.decompile(*args)

def mark_cfunc_dirty(*args):
  """
  mark_cfunc_dirty(ea, close_views=False) -> bool


  Flush the cached decompilation results. Erases a cache entry for the
  specified function.
  
  @param ea: function to erase from the cache (C++: ea_t)
  @param close_views: close pseudocode windows that show the function
                      (C++: bool)
  @return: if a cache entry existed.
  """
  return _ida_hexrays.mark_cfunc_dirty(*args)

def clear_cached_cfuncs(*args):
  """
  clear_cached_cfuncs()


  Flush all cached decompilation results.
  """
  return _ida_hexrays.clear_cached_cfuncs(*args)

def has_cached_cfunc(*args):
  """
  has_cached_cfunc(ea) -> bool


  Do we have a cached decompilation result for 'ea'?
  
  
  @param ea (C++: ea_t)
  """
  return _ida_hexrays.has_cached_cfunc(*args)

def get_ctype_name(*args):
  """
  get_ctype_name(op) -> char const *
  """
  return _ida_hexrays.get_ctype_name(*args)

def create_field_name(*args):
  """
  create_field_name(type, offset=BADADDR) -> qstring
  """
  return _ida_hexrays.create_field_name(*args)
hxe_flowchart = _ida_hexrays.hxe_flowchart
hxe_stkpnts = _ida_hexrays.hxe_stkpnts
hxe_prolog = _ida_hexrays.hxe_prolog
hxe_microcode = _ida_hexrays.hxe_microcode
hxe_preoptimized = _ida_hexrays.hxe_preoptimized
hxe_locopt = _ida_hexrays.hxe_locopt
hxe_prealloc = _ida_hexrays.hxe_prealloc
hxe_glbopt = _ida_hexrays.hxe_glbopt
hxe_structural = _ida_hexrays.hxe_structural
hxe_maturity = _ida_hexrays.hxe_maturity
hxe_interr = _ida_hexrays.hxe_interr
hxe_combine = _ida_hexrays.hxe_combine
hxe_print_func = _ida_hexrays.hxe_print_func
hxe_func_printed = _ida_hexrays.hxe_func_printed
hxe_resolve_stkaddrs = _ida_hexrays.hxe_resolve_stkaddrs
hxe_open_pseudocode = _ida_hexrays.hxe_open_pseudocode
hxe_switch_pseudocode = _ida_hexrays.hxe_switch_pseudocode
hxe_refresh_pseudocode = _ida_hexrays.hxe_refresh_pseudocode
hxe_close_pseudocode = _ida_hexrays.hxe_close_pseudocode
hxe_keyboard = _ida_hexrays.hxe_keyboard
hxe_right_click = _ida_hexrays.hxe_right_click
hxe_double_click = _ida_hexrays.hxe_double_click
hxe_curpos = _ida_hexrays.hxe_curpos
hxe_create_hint = _ida_hexrays.hxe_create_hint
hxe_text_ready = _ida_hexrays.hxe_text_ready
hxe_populating_popup = _ida_hexrays.hxe_populating_popup
lxe_lvar_name_changed = _ida_hexrays.lxe_lvar_name_changed
lxe_lvar_type_changed = _ida_hexrays.lxe_lvar_type_changed
lxe_lvar_cmt_changed = _ida_hexrays.lxe_lvar_cmt_changed
lxe_lvar_mapping_changed = _ida_hexrays.lxe_lvar_mapping_changed
hxe_cmt_changed = _ida_hexrays.hxe_cmt_changed
USE_KEYBOARD = _ida_hexrays.USE_KEYBOARD
USE_MOUSE = _ida_hexrays.USE_MOUSE
class ctext_position_t(object):
    """
    Proxy of C++ ctext_position_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lnnum = _swig_property(_ida_hexrays.ctext_position_t_lnnum_get, _ida_hexrays.ctext_position_t_lnnum_set)
    x = _swig_property(_ida_hexrays.ctext_position_t_x_get, _ida_hexrays.ctext_position_t_x_set)
    y = _swig_property(_ida_hexrays.ctext_position_t_y_get, _ida_hexrays.ctext_position_t_y_set)
    def in_ctree(self, *args):
        """
        in_ctree(self, hdrlines) -> bool
        """
        return _ida_hexrays.ctext_position_t_in_ctree(self, *args)

    def __eq__(self, *args):
        """
        __eq__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___ne__(self, *args)

    def __lt__(self, *args):
        """
        __lt__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___lt__(self, *args)

    def __gt__(self, *args):
        """
        __gt__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___gt__(self, *args)

    def __le__(self, *args):
        """
        __le__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___le__(self, *args)

    def __ge__(self, *args):
        """
        __ge__(self, r) -> bool
        """
        return _ida_hexrays.ctext_position_t___ge__(self, *args)

    def compare(self, *args):
        """
        compare(self, r) -> int
        """
        return _ida_hexrays.ctext_position_t_compare(self, *args)

    def __init__(self, *args):
        """
        __init__(self, _lnnum=-1, _x=0, _y=0) -> ctext_position_t
        """
        this = _ida_hexrays.new_ctext_position_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_ctext_position_t
    __del__ = lambda self : None;
ctext_position_t_swigregister = _ida_hexrays.ctext_position_t_swigregister
ctext_position_t_swigregister(ctext_position_t)
HEXRAYS_API_MAGIC = cvar.HEXRAYS_API_MAGIC

def compare(*args):
  """
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    compare(a, b) -> int
    """
  return _ida_hexrays.compare(*args)

class history_item_t(ctext_position_t):
    """
    Proxy of C++ history_item_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ea = _swig_property(_ida_hexrays.history_item_t_ea_get, _ida_hexrays.history_item_t_ea_set)
    end = _swig_property(_ida_hexrays.history_item_t_end_get, _ida_hexrays.history_item_t_end_set)
    def __init__(self, *args):
        """
        __init__(self, _ea=BADADDR, _lnnum=-1, _x=0, _y=0) -> history_item_t
        __init__(self, _ea, p) -> history_item_t
        """
        this = _ida_hexrays.new_history_item_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_history_item_t
    __del__ = lambda self : None;
history_item_t_swigregister = _ida_hexrays.history_item_t_swigregister
history_item_t_swigregister(history_item_t)

class vdui_t(object):
    """
    Proxy of C++ vdui_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    flags = _swig_property(_ida_hexrays.vdui_t_flags_get, _ida_hexrays.vdui_t_flags_set)
    def visible(self, *args):
        """
        visible(self) -> bool
        """
        return _ida_hexrays.vdui_t_visible(self, *args)

    def valid(self, *args):
        """
        valid(self) -> bool
        """
        return _ida_hexrays.vdui_t_valid(self, *args)

    def locked(self, *args):
        """
        locked(self) -> bool
        """
        return _ida_hexrays.vdui_t_locked(self, *args)

    def set_visible(self, *args):
        """
        set_visible(self, v)
        """
        return _ida_hexrays.vdui_t_set_visible(self, *args)

    def set_valid(self, *args):
        """
        set_valid(self, v)
        """
        return _ida_hexrays.vdui_t_set_valid(self, *args)

    def set_locked(self, *args):
        """
        set_locked(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_set_locked(self, *args)

    view_idx = _swig_property(_ida_hexrays.vdui_t_view_idx_get, _ida_hexrays.vdui_t_view_idx_set)
    ct = _swig_property(_ida_hexrays.vdui_t_ct_get, _ida_hexrays.vdui_t_ct_set)
    toplevel = _swig_property(_ida_hexrays.vdui_t_toplevel_get, _ida_hexrays.vdui_t_toplevel_set)
    mba = _swig_property(_ida_hexrays.vdui_t_mba_get, _ida_hexrays.vdui_t_mba_set)
    cfunc = _swig_property(_ida_hexrays.vdui_t_cfunc_get, _ida_hexrays.vdui_t_cfunc_set)
    last_code = _swig_property(_ida_hexrays.vdui_t_last_code_get, _ida_hexrays.vdui_t_last_code_set)
    cpos = _swig_property(_ida_hexrays.vdui_t_cpos_get, _ida_hexrays.vdui_t_cpos_set)
    head = _swig_property(_ida_hexrays.vdui_t_head_get, _ida_hexrays.vdui_t_head_set)
    item = _swig_property(_ida_hexrays.vdui_t_item_get, _ida_hexrays.vdui_t_item_set)
    tail = _swig_property(_ida_hexrays.vdui_t_tail_get, _ida_hexrays.vdui_t_tail_set)
    def refresh_view(self, *args):
        """
        refresh_view(self, redo_mba)
        """
        return _ida_hexrays.vdui_t_refresh_view(self, *args)

    def refresh_ctext(self, *args):
        """
        refresh_ctext(self, activate=True)
        """
        return _ida_hexrays.vdui_t_refresh_ctext(self, *args)

    def switch_to(self, *args):
        """
        switch_to(self, f, activate)
        """
        return _ida_hexrays.vdui_t_switch_to(self, *args)

    def in_ctree(self, *args):
        """
        in_ctree(self) -> bool
        """
        return _ida_hexrays.vdui_t_in_ctree(self, *args)

    def get_number(self, *args):
        """
        get_number(self) -> cnumber_t
        """
        return _ida_hexrays.vdui_t_get_number(self, *args)

    def get_current_label(self, *args):
        """
        get_current_label(self) -> int
        """
        return _ida_hexrays.vdui_t_get_current_label(self, *args)

    def clear(self, *args):
        """
        clear(self)
        """
        return _ida_hexrays.vdui_t_clear(self, *args)

    def refresh_cpos(self, *args):
        """
        refresh_cpos(self, idv) -> bool
        """
        return _ida_hexrays.vdui_t_refresh_cpos(self, *args)

    def get_current_item(self, *args):
        """
        get_current_item(self, idv) -> bool
        """
        return _ida_hexrays.vdui_t_get_current_item(self, *args)

    def ui_rename_lvar(self, *args):
        """
        ui_rename_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_rename_lvar(self, *args)

    def rename_lvar(self, *args):
        """
        rename_lvar(self, v, name, is_user_name) -> bool
        """
        return _ida_hexrays.vdui_t_rename_lvar(self, *args)

    def ui_set_call_type(self, *args):
        """
        ui_set_call_type(self, e) -> bool
        """
        return _ida_hexrays.vdui_t_ui_set_call_type(self, *args)

    def ui_set_lvar_type(self, *args):
        """
        ui_set_lvar_type(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_set_lvar_type(self, *args)

    def set_lvar_type(self, *args):
        """
        set_lvar_type(self, v, type) -> bool
        """
        return _ida_hexrays.vdui_t_set_lvar_type(self, *args)

    def set_noptr_lvar(self, *args):
        """
        set_noptr_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_set_noptr_lvar(self, *args)

    def ui_edit_lvar_cmt(self, *args):
        """
        ui_edit_lvar_cmt(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_edit_lvar_cmt(self, *args)

    def set_lvar_cmt(self, *args):
        """
        set_lvar_cmt(self, v, cmt) -> bool
        """
        return _ida_hexrays.vdui_t_set_lvar_cmt(self, *args)

    def ui_map_lvar(self, *args):
        """
        ui_map_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_map_lvar(self, *args)

    def ui_unmap_lvar(self, *args):
        """
        ui_unmap_lvar(self, v) -> bool
        """
        return _ida_hexrays.vdui_t_ui_unmap_lvar(self, *args)

    def map_lvar(self, *args):
        """
        map_lvar(self, _from, to) -> bool
        """
        return _ida_hexrays.vdui_t_map_lvar(self, *args)

    def set_strmem_type(self, *args):
        """
        set_strmem_type(self, sptr, mptr) -> bool
        """
        return _ida_hexrays.vdui_t_set_strmem_type(self, *args)

    def rename_strmem(self, *args):
        """
        rename_strmem(self, sptr, mptr) -> bool
        """
        return _ida_hexrays.vdui_t_rename_strmem(self, *args)

    def set_global_type(self, *args):
        """
        set_global_type(self, ea) -> bool
        """
        return _ida_hexrays.vdui_t_set_global_type(self, *args)

    def rename_global(self, *args):
        """
        rename_global(self, ea) -> bool
        """
        return _ida_hexrays.vdui_t_rename_global(self, *args)

    def rename_label(self, *args):
        """
        rename_label(self, label) -> bool
        """
        return _ida_hexrays.vdui_t_rename_label(self, *args)

    def jump_enter(self, *args):
        """
        jump_enter(self, idv, omflags) -> bool
        """
        return _ida_hexrays.vdui_t_jump_enter(self, *args)

    def ctree_to_disasm(self, *args):
        """
        ctree_to_disasm(self) -> bool
        """
        return _ida_hexrays.vdui_t_ctree_to_disasm(self, *args)

    def calc_cmt_type(self, *args):
        """
        calc_cmt_type(self, lnnum, cmttype) -> cmt_type_t
        """
        return _ida_hexrays.vdui_t_calc_cmt_type(self, *args)

    def edit_cmt(self, *args):
        """
        edit_cmt(self, loc) -> bool
        """
        return _ida_hexrays.vdui_t_edit_cmt(self, *args)

    def edit_func_cmt(self, *args):
        """
        edit_func_cmt(self) -> bool
        """
        return _ida_hexrays.vdui_t_edit_func_cmt(self, *args)

    def del_orphan_cmts(self, *args):
        """
        del_orphan_cmts(self) -> bool
        """
        return _ida_hexrays.vdui_t_del_orphan_cmts(self, *args)

    def set_num_radix(self, *args):
        """
        set_num_radix(self, base) -> bool
        """
        return _ida_hexrays.vdui_t_set_num_radix(self, *args)

    def set_num_enum(self, *args):
        """
        set_num_enum(self) -> bool
        """
        return _ida_hexrays.vdui_t_set_num_enum(self, *args)

    def set_num_stroff(self, *args):
        """
        set_num_stroff(self) -> bool
        """
        return _ida_hexrays.vdui_t_set_num_stroff(self, *args)

    def invert_sign(self, *args):
        """
        invert_sign(self) -> bool
        """
        return _ida_hexrays.vdui_t_invert_sign(self, *args)

    def invert_bits(self, *args):
        """
        invert_bits(self) -> bool
        """
        return _ida_hexrays.vdui_t_invert_bits(self, *args)

    def collapse_item(self, *args):
        """
        collapse_item(self, hide) -> bool
        """
        return _ida_hexrays.vdui_t_collapse_item(self, *args)

    def collapse_lvars(self, *args):
        """
        collapse_lvars(self, hide) -> bool
        """
        return _ida_hexrays.vdui_t_collapse_lvars(self, *args)

    def split_item(self, *args):
        """
        split_item(self, split) -> bool
        """
        return _ida_hexrays.vdui_t_split_item(self, *args)

    __swig_destroy__ = _ida_hexrays.delete_vdui_t
    __del__ = lambda self : None;
vdui_t_swigregister = _ida_hexrays.vdui_t_swigregister
vdui_t_swigregister(vdui_t)
CMT_NONE = cvar.CMT_NONE
CMT_TAIL = cvar.CMT_TAIL
CMT_BLOCK1 = cvar.CMT_BLOCK1
CMT_BLOCK2 = cvar.CMT_BLOCK2
CMT_LVAR = cvar.CMT_LVAR
CMT_FUNC = cvar.CMT_FUNC
CMT_ALL = cvar.CMT_ALL
VDUI_VISIBLE = _ida_hexrays.VDUI_VISIBLE
"""
is visible?
"""
VDUI_VALID = _ida_hexrays.VDUI_VALID
"""
is valid?
"""
VDUI_LOCKED = _ida_hexrays.VDUI_LOCKED
"""
is locked?
"""

hx_user_numforms_begin = _ida_hexrays.hx_user_numforms_begin
hx_user_numforms_end = _ida_hexrays.hx_user_numforms_end
hx_user_numforms_next = _ida_hexrays.hx_user_numforms_next
hx_user_numforms_prev = _ida_hexrays.hx_user_numforms_prev
hx_user_numforms_first = _ida_hexrays.hx_user_numforms_first
hx_user_numforms_second = _ida_hexrays.hx_user_numforms_second
hx_user_numforms_find = _ida_hexrays.hx_user_numforms_find
hx_user_numforms_insert = _ida_hexrays.hx_user_numforms_insert
hx_user_numforms_erase = _ida_hexrays.hx_user_numforms_erase
hx_user_numforms_clear = _ida_hexrays.hx_user_numforms_clear
hx_user_numforms_size = _ida_hexrays.hx_user_numforms_size
hx_user_numforms_free = _ida_hexrays.hx_user_numforms_free
hx_user_numforms_new = _ida_hexrays.hx_user_numforms_new
hx_lvar_mapping_begin = _ida_hexrays.hx_lvar_mapping_begin
hx_lvar_mapping_end = _ida_hexrays.hx_lvar_mapping_end
hx_lvar_mapping_next = _ida_hexrays.hx_lvar_mapping_next
hx_lvar_mapping_prev = _ida_hexrays.hx_lvar_mapping_prev
hx_lvar_mapping_first = _ida_hexrays.hx_lvar_mapping_first
hx_lvar_mapping_second = _ida_hexrays.hx_lvar_mapping_second
hx_lvar_mapping_find = _ida_hexrays.hx_lvar_mapping_find
hx_lvar_mapping_insert = _ida_hexrays.hx_lvar_mapping_insert
hx_lvar_mapping_erase = _ida_hexrays.hx_lvar_mapping_erase
hx_lvar_mapping_clear = _ida_hexrays.hx_lvar_mapping_clear
hx_lvar_mapping_size = _ida_hexrays.hx_lvar_mapping_size
hx_lvar_mapping_free = _ida_hexrays.hx_lvar_mapping_free
hx_lvar_mapping_new = _ida_hexrays.hx_lvar_mapping_new
hx_udcall_map_begin = _ida_hexrays.hx_udcall_map_begin
hx_udcall_map_end = _ida_hexrays.hx_udcall_map_end
hx_udcall_map_next = _ida_hexrays.hx_udcall_map_next
hx_udcall_map_prev = _ida_hexrays.hx_udcall_map_prev
hx_udcall_map_first = _ida_hexrays.hx_udcall_map_first
hx_udcall_map_second = _ida_hexrays.hx_udcall_map_second
hx_udcall_map_find = _ida_hexrays.hx_udcall_map_find
hx_udcall_map_insert = _ida_hexrays.hx_udcall_map_insert
hx_udcall_map_erase = _ida_hexrays.hx_udcall_map_erase
hx_udcall_map_clear = _ida_hexrays.hx_udcall_map_clear
hx_udcall_map_size = _ida_hexrays.hx_udcall_map_size
hx_udcall_map_free = _ida_hexrays.hx_udcall_map_free
hx_udcall_map_new = _ida_hexrays.hx_udcall_map_new
hx_user_cmts_begin = _ida_hexrays.hx_user_cmts_begin
hx_user_cmts_end = _ida_hexrays.hx_user_cmts_end
hx_user_cmts_next = _ida_hexrays.hx_user_cmts_next
hx_user_cmts_prev = _ida_hexrays.hx_user_cmts_prev
hx_user_cmts_first = _ida_hexrays.hx_user_cmts_first
hx_user_cmts_second = _ida_hexrays.hx_user_cmts_second
hx_user_cmts_find = _ida_hexrays.hx_user_cmts_find
hx_user_cmts_insert = _ida_hexrays.hx_user_cmts_insert
hx_user_cmts_erase = _ida_hexrays.hx_user_cmts_erase
hx_user_cmts_clear = _ida_hexrays.hx_user_cmts_clear
hx_user_cmts_size = _ida_hexrays.hx_user_cmts_size
hx_user_cmts_free = _ida_hexrays.hx_user_cmts_free
hx_user_cmts_new = _ida_hexrays.hx_user_cmts_new
hx_user_iflags_begin = _ida_hexrays.hx_user_iflags_begin
hx_user_iflags_end = _ida_hexrays.hx_user_iflags_end
hx_user_iflags_next = _ida_hexrays.hx_user_iflags_next
hx_user_iflags_prev = _ida_hexrays.hx_user_iflags_prev
hx_user_iflags_first = _ida_hexrays.hx_user_iflags_first
hx_user_iflags_second = _ida_hexrays.hx_user_iflags_second
hx_user_iflags_find = _ida_hexrays.hx_user_iflags_find
hx_user_iflags_insert = _ida_hexrays.hx_user_iflags_insert
hx_user_iflags_erase = _ida_hexrays.hx_user_iflags_erase
hx_user_iflags_clear = _ida_hexrays.hx_user_iflags_clear
hx_user_iflags_size = _ida_hexrays.hx_user_iflags_size
hx_user_iflags_free = _ida_hexrays.hx_user_iflags_free
hx_user_iflags_new = _ida_hexrays.hx_user_iflags_new
hx_user_unions_begin = _ida_hexrays.hx_user_unions_begin
hx_user_unions_end = _ida_hexrays.hx_user_unions_end
hx_user_unions_next = _ida_hexrays.hx_user_unions_next
hx_user_unions_prev = _ida_hexrays.hx_user_unions_prev
hx_user_unions_first = _ida_hexrays.hx_user_unions_first
hx_user_unions_second = _ida_hexrays.hx_user_unions_second
hx_user_unions_find = _ida_hexrays.hx_user_unions_find
hx_user_unions_insert = _ida_hexrays.hx_user_unions_insert
hx_user_unions_erase = _ida_hexrays.hx_user_unions_erase
hx_user_unions_clear = _ida_hexrays.hx_user_unions_clear
hx_user_unions_size = _ida_hexrays.hx_user_unions_size
hx_user_unions_free = _ida_hexrays.hx_user_unions_free
hx_user_unions_new = _ida_hexrays.hx_user_unions_new
hx_user_labels_begin = _ida_hexrays.hx_user_labels_begin
hx_user_labels_end = _ida_hexrays.hx_user_labels_end
hx_user_labels_next = _ida_hexrays.hx_user_labels_next
hx_user_labels_prev = _ida_hexrays.hx_user_labels_prev
hx_user_labels_first = _ida_hexrays.hx_user_labels_first
hx_user_labels_second = _ida_hexrays.hx_user_labels_second
hx_user_labels_find = _ida_hexrays.hx_user_labels_find
hx_user_labels_insert = _ida_hexrays.hx_user_labels_insert
hx_user_labels_erase = _ida_hexrays.hx_user_labels_erase
hx_user_labels_clear = _ida_hexrays.hx_user_labels_clear
hx_user_labels_size = _ida_hexrays.hx_user_labels_size
hx_user_labels_free = _ida_hexrays.hx_user_labels_free
hx_user_labels_new = _ida_hexrays.hx_user_labels_new
hx_eamap_begin = _ida_hexrays.hx_eamap_begin
hx_eamap_end = _ida_hexrays.hx_eamap_end
hx_eamap_next = _ida_hexrays.hx_eamap_next
hx_eamap_prev = _ida_hexrays.hx_eamap_prev
hx_eamap_first = _ida_hexrays.hx_eamap_first
hx_eamap_second = _ida_hexrays.hx_eamap_second
hx_eamap_find = _ida_hexrays.hx_eamap_find
hx_eamap_insert = _ida_hexrays.hx_eamap_insert
hx_eamap_erase = _ida_hexrays.hx_eamap_erase
hx_eamap_clear = _ida_hexrays.hx_eamap_clear
hx_eamap_size = _ida_hexrays.hx_eamap_size
hx_eamap_free = _ida_hexrays.hx_eamap_free
hx_eamap_new = _ida_hexrays.hx_eamap_new
hx_boundaries_begin = _ida_hexrays.hx_boundaries_begin
hx_boundaries_end = _ida_hexrays.hx_boundaries_end
hx_boundaries_next = _ida_hexrays.hx_boundaries_next
hx_boundaries_prev = _ida_hexrays.hx_boundaries_prev
hx_boundaries_first = _ida_hexrays.hx_boundaries_first
hx_boundaries_second = _ida_hexrays.hx_boundaries_second
hx_boundaries_find = _ida_hexrays.hx_boundaries_find
hx_boundaries_insert = _ida_hexrays.hx_boundaries_insert
hx_boundaries_erase = _ida_hexrays.hx_boundaries_erase
hx_boundaries_clear = _ida_hexrays.hx_boundaries_clear
hx_boundaries_size = _ida_hexrays.hx_boundaries_size
hx_boundaries_free = _ida_hexrays.hx_boundaries_free
hx_boundaries_new = _ida_hexrays.hx_boundaries_new
hx_block_chains_begin = _ida_hexrays.hx_block_chains_begin
hx_block_chains_end = _ida_hexrays.hx_block_chains_end
hx_block_chains_next = _ida_hexrays.hx_block_chains_next
hx_block_chains_prev = _ida_hexrays.hx_block_chains_prev
hx_block_chains_get = _ida_hexrays.hx_block_chains_get
hx_block_chains_find = _ida_hexrays.hx_block_chains_find
hx_block_chains_insert = _ida_hexrays.hx_block_chains_insert
hx_block_chains_erase = _ida_hexrays.hx_block_chains_erase
hx_block_chains_clear = _ida_hexrays.hx_block_chains_clear
hx_block_chains_size = _ida_hexrays.hx_block_chains_size
hx_block_chains_free = _ida_hexrays.hx_block_chains_free
hx_block_chains_new = _ida_hexrays.hx_block_chains_new
hx_valrng_t_clear = _ida_hexrays.hx_valrng_t_clear
hx_valrng_t_copy = _ida_hexrays.hx_valrng_t_copy
hx_valrng_t_assign = _ida_hexrays.hx_valrng_t_assign
hx_valrng_t_compare = _ida_hexrays.hx_valrng_t_compare
hx_valrng_t_set_eq = _ida_hexrays.hx_valrng_t_set_eq
hx_valrng_t_set_cmp = _ida_hexrays.hx_valrng_t_set_cmp
hx_valrng_t_reduce_size = _ida_hexrays.hx_valrng_t_reduce_size
hx_valrng_t_intersect_with = _ida_hexrays.hx_valrng_t_intersect_with
hx_valrng_t_unite_with = _ida_hexrays.hx_valrng_t_unite_with
hx_valrng_t_inverse = _ida_hexrays.hx_valrng_t_inverse
hx_valrng_t_has = _ida_hexrays.hx_valrng_t_has
hx_valrng_t_print = _ida_hexrays.hx_valrng_t_print
hx_valrng_t_dstr = _ida_hexrays.hx_valrng_t_dstr
hx_valrng_t_cvt_to_single_value = _ida_hexrays.hx_valrng_t_cvt_to_single_value
hx_valrng_t_cvt_to_cmp = _ida_hexrays.hx_valrng_t_cvt_to_cmp
hx_get_merror_desc = _ida_hexrays.hx_get_merror_desc
hx_reg2mreg = _ida_hexrays.hx_reg2mreg
hx_mreg2reg = _ida_hexrays.hx_mreg2reg
hx_install_optinsn_handler = _ida_hexrays.hx_install_optinsn_handler
hx_remove_optinsn_handler = _ida_hexrays.hx_remove_optinsn_handler
hx_install_optblock_handler = _ida_hexrays.hx_install_optblock_handler
hx_remove_optblock_handler = _ida_hexrays.hx_remove_optblock_handler
hx_must_mcode_close_block = _ida_hexrays.hx_must_mcode_close_block
hx_is_mcode_propagatable = _ida_hexrays.hx_is_mcode_propagatable
hx_negate_mcode_relation = _ida_hexrays.hx_negate_mcode_relation
hx_swap_mcode_relation = _ida_hexrays.hx_swap_mcode_relation
hx_get_signed_mcode = _ida_hexrays.hx_get_signed_mcode
hx_get_unsigned_mcode = _ida_hexrays.hx_get_unsigned_mcode
hx_mcode_modifies_d = _ida_hexrays.hx_mcode_modifies_d
hx_operand_locator_t_compare = _ida_hexrays.hx_operand_locator_t_compare
hx_vd_printer_t_print = _ida_hexrays.hx_vd_printer_t_print
hx_file_printer_t_print = _ida_hexrays.hx_file_printer_t_print
hx_qstring_printer_t_print = _ida_hexrays.hx_qstring_printer_t_print
hx_dstr = _ida_hexrays.hx_dstr
hx_is_type_correct = _ida_hexrays.hx_is_type_correct
hx_is_small_struni = _ida_hexrays.hx_is_small_struni
hx_is_nonbool_type = _ida_hexrays.hx_is_nonbool_type
hx_is_bool_type = _ida_hexrays.hx_is_bool_type
hx_partial_type_num = _ida_hexrays.hx_partial_type_num
hx_get_float_type = _ida_hexrays.hx_get_float_type
hx_get_int_type_by_width_and_sign = _ida_hexrays.hx_get_int_type_by_width_and_sign
hx_get_unk_type = _ida_hexrays.hx_get_unk_type
hx_dummy_ptrtype = _ida_hexrays.hx_dummy_ptrtype
hx_get_member_type = _ida_hexrays.hx_get_member_type
hx_make_pointer = _ida_hexrays.hx_make_pointer
hx_create_typedef = _ida_hexrays.hx_create_typedef
hx_get_type = _ida_hexrays.hx_get_type
hx_set_type = _ida_hexrays.hx_set_type
hx_vdloc_t_dstr = _ida_hexrays.hx_vdloc_t_dstr
hx_vdloc_t_compare = _ida_hexrays.hx_vdloc_t_compare
hx_vdloc_t_is_aliasable = _ida_hexrays.hx_vdloc_t_is_aliasable
hx_print_vdloc = _ida_hexrays.hx_print_vdloc
hx_arglocs_overlap = _ida_hexrays.hx_arglocs_overlap
hx_lvar_locator_t_compare = _ida_hexrays.hx_lvar_locator_t_compare
hx_lvar_locator_t_dstr = _ida_hexrays.hx_lvar_locator_t_dstr
hx_lvar_t_dstr = _ida_hexrays.hx_lvar_t_dstr
hx_lvar_t_is_promoted_arg = _ida_hexrays.hx_lvar_t_is_promoted_arg
hx_lvar_t_accepts_type = _ida_hexrays.hx_lvar_t_accepts_type
hx_lvar_t_set_lvar_type = _ida_hexrays.hx_lvar_t_set_lvar_type
hx_lvar_t_set_width = _ida_hexrays.hx_lvar_t_set_width
hx_lvar_t_append_list = _ida_hexrays.hx_lvar_t_append_list
hx_lvars_t_find_stkvar = _ida_hexrays.hx_lvars_t_find_stkvar
hx_lvars_t_find = _ida_hexrays.hx_lvars_t_find
hx_lvars_t_find_lvar = _ida_hexrays.hx_lvars_t_find_lvar
hx_restore_user_lvar_settings = _ida_hexrays.hx_restore_user_lvar_settings
hx_save_user_lvar_settings = _ida_hexrays.hx_save_user_lvar_settings
hx_modify_user_lvars = _ida_hexrays.hx_modify_user_lvars
hx_restore_user_defined_calls = _ida_hexrays.hx_restore_user_defined_calls
hx_save_user_defined_calls = _ida_hexrays.hx_save_user_defined_calls
hx_parse_user_call = _ida_hexrays.hx_parse_user_call
hx_convert_to_user_call = _ida_hexrays.hx_convert_to_user_call
hx_install_microcode_filter = _ida_hexrays.hx_install_microcode_filter
hx_udc_filter_t_init = _ida_hexrays.hx_udc_filter_t_init
hx_udc_filter_t_apply = _ida_hexrays.hx_udc_filter_t_apply
hx_bitset_t_bitset_t = _ida_hexrays.hx_bitset_t_bitset_t
hx_bitset_t_copy = _ida_hexrays.hx_bitset_t_copy
hx_bitset_t_add = _ida_hexrays.hx_bitset_t_add
hx_bitset_t_add_ = _ida_hexrays.hx_bitset_t_add_
hx_bitset_t_add__ = _ida_hexrays.hx_bitset_t_add__
hx_bitset_t_sub = _ida_hexrays.hx_bitset_t_sub
hx_bitset_t_sub_ = _ida_hexrays.hx_bitset_t_sub_
hx_bitset_t_sub__ = _ida_hexrays.hx_bitset_t_sub__
hx_bitset_t_cut_at = _ida_hexrays.hx_bitset_t_cut_at
hx_bitset_t_shift_down = _ida_hexrays.hx_bitset_t_shift_down
hx_bitset_t_has = _ida_hexrays.hx_bitset_t_has
hx_bitset_t_has_all = _ida_hexrays.hx_bitset_t_has_all
hx_bitset_t_has_any = _ida_hexrays.hx_bitset_t_has_any
hx_bitset_t_dstr = _ida_hexrays.hx_bitset_t_dstr
hx_bitset_t_empty = _ida_hexrays.hx_bitset_t_empty
hx_bitset_t_count = _ida_hexrays.hx_bitset_t_count
hx_bitset_t_count_ = _ida_hexrays.hx_bitset_t_count_
hx_bitset_t_last = _ida_hexrays.hx_bitset_t_last
hx_bitset_t_fill_with_ones = _ida_hexrays.hx_bitset_t_fill_with_ones
hx_bitset_t_has_common = _ida_hexrays.hx_bitset_t_has_common
hx_bitset_t_intersect = _ida_hexrays.hx_bitset_t_intersect
hx_bitset_t_is_subset_of = _ida_hexrays.hx_bitset_t_is_subset_of
hx_bitset_t_compare = _ida_hexrays.hx_bitset_t_compare
hx_bitset_t_goup = _ida_hexrays.hx_bitset_t_goup
hx_ivl_t_dstr = _ida_hexrays.hx_ivl_t_dstr
hx_ivl_t_compare = _ida_hexrays.hx_ivl_t_compare
hx_ivlset_t_add = _ida_hexrays.hx_ivlset_t_add
hx_ivlset_t_add_ = _ida_hexrays.hx_ivlset_t_add_
hx_ivlset_t_addmasked = _ida_hexrays.hx_ivlset_t_addmasked
hx_ivlset_t_sub = _ida_hexrays.hx_ivlset_t_sub
hx_ivlset_t_sub_ = _ida_hexrays.hx_ivlset_t_sub_
hx_ivlset_t_has_common = _ida_hexrays.hx_ivlset_t_has_common
hx_ivlset_t_print = _ida_hexrays.hx_ivlset_t_print
hx_ivlset_t_dstr = _ida_hexrays.hx_ivlset_t_dstr
hx_ivlset_t_count = _ida_hexrays.hx_ivlset_t_count
hx_ivlset_t_has_common_ = _ida_hexrays.hx_ivlset_t_has_common_
hx_ivlset_t_contains = _ida_hexrays.hx_ivlset_t_contains
hx_ivlset_t_includes = _ida_hexrays.hx_ivlset_t_includes
hx_ivlset_t_intersect = _ida_hexrays.hx_ivlset_t_intersect
hx_ivlset_t_compare = _ida_hexrays.hx_ivlset_t_compare
hx_get_mreg_name = _ida_hexrays.hx_get_mreg_name
hx_rlist_t_print = _ida_hexrays.hx_rlist_t_print
hx_rlist_t_dstr = _ida_hexrays.hx_rlist_t_dstr
hx_mlist_t_addmem = _ida_hexrays.hx_mlist_t_addmem
hx_mlist_t_print = _ida_hexrays.hx_mlist_t_print
hx_mlist_t_dstr = _ida_hexrays.hx_mlist_t_dstr
hx_mlist_t_compare = _ida_hexrays.hx_mlist_t_compare
hx_lvar_ref_t_compare = _ida_hexrays.hx_lvar_ref_t_compare
hx_lvar_ref_t_var = _ida_hexrays.hx_lvar_ref_t_var
hx_stkvar_ref_t_compare = _ida_hexrays.hx_stkvar_ref_t_compare
hx_stkvar_ref_t_get_stkvar = _ida_hexrays.hx_stkvar_ref_t_get_stkvar
hx_fnumber_t_print = _ida_hexrays.hx_fnumber_t_print
hx_fnumber_t_dstr = _ida_hexrays.hx_fnumber_t_dstr
hx_mop_t_copy = _ida_hexrays.hx_mop_t_copy
hx_mop_t_assign = _ida_hexrays.hx_mop_t_assign
hx_mop_t_swap = _ida_hexrays.hx_mop_t_swap
hx_mop_t_erase = _ida_hexrays.hx_mop_t_erase
hx_mop_t_print = _ida_hexrays.hx_mop_t_print
hx_mop_t_dstr = _ida_hexrays.hx_mop_t_dstr
hx_mop_t_create_from_mlist = _ida_hexrays.hx_mop_t_create_from_mlist
hx_mop_t_create_from_ivlset = _ida_hexrays.hx_mop_t_create_from_ivlset
hx_mop_t_create_from_vdloc = _ida_hexrays.hx_mop_t_create_from_vdloc
hx_mop_t_create_from_scattered_vdloc = _ida_hexrays.hx_mop_t_create_from_scattered_vdloc
hx_mop_t_create_from_insn = _ida_hexrays.hx_mop_t_create_from_insn
hx_mop_t_make_number = _ida_hexrays.hx_mop_t_make_number
hx_mop_t_make_fpnum = _ida_hexrays.hx_mop_t_make_fpnum
hx_mop_t_make_reg_pair = _ida_hexrays.hx_mop_t_make_reg_pair
hx_mop_t_make_helper = _ida_hexrays.hx_mop_t_make_helper
hx_mop_t_is_bit_reg = _ida_hexrays.hx_mop_t_is_bit_reg
hx_mop_t_may_use_aliased_memory = _ida_hexrays.hx_mop_t_may_use_aliased_memory
hx_mop_t_is01 = _ida_hexrays.hx_mop_t_is01
hx_mop_t_is_sign_extended_from = _ida_hexrays.hx_mop_t_is_sign_extended_from
hx_mop_t_is_zero_extended_from = _ida_hexrays.hx_mop_t_is_zero_extended_from
hx_mop_t_equal_mops = _ida_hexrays.hx_mop_t_equal_mops
hx_mop_t_lexcompare = _ida_hexrays.hx_mop_t_lexcompare
hx_mop_t_for_all_ops = _ida_hexrays.hx_mop_t_for_all_ops
hx_mop_t_for_all_scattered_submops = _ida_hexrays.hx_mop_t_for_all_scattered_submops
hx_mop_t_is_constant = _ida_hexrays.hx_mop_t_is_constant
hx_mop_t_get_stkoff = _ida_hexrays.hx_mop_t_get_stkoff
hx_mop_t_make_low_half = _ida_hexrays.hx_mop_t_make_low_half
hx_mop_t_make_high_half = _ida_hexrays.hx_mop_t_make_high_half
hx_mop_t_make_first_half = _ida_hexrays.hx_mop_t_make_first_half
hx_mop_t_make_second_half = _ida_hexrays.hx_mop_t_make_second_half
hx_mop_t_shift_mop = _ida_hexrays.hx_mop_t_shift_mop
hx_mop_t_change_size = _ida_hexrays.hx_mop_t_change_size
hx_mop_t_preserve_side_effects = _ida_hexrays.hx_mop_t_preserve_side_effects
hx_mop_t_apply_ld_mcode = _ida_hexrays.hx_mop_t_apply_ld_mcode
hx_mcallarg_t_print = _ida_hexrays.hx_mcallarg_t_print
hx_mcallarg_t_dstr = _ida_hexrays.hx_mcallarg_t_dstr
hx_mcallarg_t_set_regarg = _ida_hexrays.hx_mcallarg_t_set_regarg
hx_mcallinfo_t_lexcompare = _ida_hexrays.hx_mcallinfo_t_lexcompare
hx_mcallinfo_t_set_type = _ida_hexrays.hx_mcallinfo_t_set_type
hx_mcallinfo_t_get_type = _ida_hexrays.hx_mcallinfo_t_get_type
hx_mcallinfo_t_print = _ida_hexrays.hx_mcallinfo_t_print
hx_mcallinfo_t_dstr = _ida_hexrays.hx_mcallinfo_t_dstr
hx_mcases_t_compare = _ida_hexrays.hx_mcases_t_compare
hx_mcases_t_print = _ida_hexrays.hx_mcases_t_print
hx_mcases_t_dstr = _ida_hexrays.hx_mcases_t_dstr
hx_vivl_t_extend_to_cover = _ida_hexrays.hx_vivl_t_extend_to_cover
hx_vivl_t_intersect = _ida_hexrays.hx_vivl_t_intersect
hx_vivl_t_print = _ida_hexrays.hx_vivl_t_print
hx_vivl_t_dstr = _ida_hexrays.hx_vivl_t_dstr
hx_chain_t_print = _ida_hexrays.hx_chain_t_print
hx_chain_t_dstr = _ida_hexrays.hx_chain_t_dstr
hx_chain_t_append_list = _ida_hexrays.hx_chain_t_append_list
hx_block_chains_t_get_chain = _ida_hexrays.hx_block_chains_t_get_chain
hx_block_chains_t_print = _ida_hexrays.hx_block_chains_t_print
hx_block_chains_t_dstr = _ida_hexrays.hx_block_chains_t_dstr
hx_graph_chains_t_for_all_chains = _ida_hexrays.hx_graph_chains_t_for_all_chains
hx_graph_chains_t_release = _ida_hexrays.hx_graph_chains_t_release
hx_minsn_t_init = _ida_hexrays.hx_minsn_t_init
hx_minsn_t_copy = _ida_hexrays.hx_minsn_t_copy
hx_minsn_t_swap = _ida_hexrays.hx_minsn_t_swap
hx_minsn_t_print = _ida_hexrays.hx_minsn_t_print
hx_minsn_t_dstr = _ida_hexrays.hx_minsn_t_dstr
hx_minsn_t_setaddr = _ida_hexrays.hx_minsn_t_setaddr
hx_minsn_t_optimize_subtree = _ida_hexrays.hx_minsn_t_optimize_subtree
hx_minsn_t_for_all_ops = _ida_hexrays.hx_minsn_t_for_all_ops
hx_minsn_t_for_all_insns = _ida_hexrays.hx_minsn_t_for_all_insns
hx_minsn_t__make_nop = _ida_hexrays.hx_minsn_t__make_nop
hx_minsn_t_equal_insns = _ida_hexrays.hx_minsn_t_equal_insns
hx_minsn_t_lexcompare = _ida_hexrays.hx_minsn_t_lexcompare
hx_minsn_t_is_noret_call = _ida_hexrays.hx_minsn_t_is_noret_call
hx_minsn_t_is_helper = _ida_hexrays.hx_minsn_t_is_helper
hx_minsn_t_find_call = _ida_hexrays.hx_minsn_t_find_call
hx_minsn_t_has_side_effects = _ida_hexrays.hx_minsn_t_has_side_effects
hx_minsn_t_find_opcode = _ida_hexrays.hx_minsn_t_find_opcode
hx_minsn_t_find_ins_op = _ida_hexrays.hx_minsn_t_find_ins_op
hx_minsn_t_find_num_op = _ida_hexrays.hx_minsn_t_find_num_op
hx_minsn_t_modifes_d = _ida_hexrays.hx_minsn_t_modifes_d
hx_minsn_t_is_between = _ida_hexrays.hx_minsn_t_is_between
hx_minsn_t_may_use_aliased_memory = _ida_hexrays.hx_minsn_t_may_use_aliased_memory
hx_getf_reginsn = _ida_hexrays.hx_getf_reginsn
hx_getb_reginsn = _ida_hexrays.hx_getb_reginsn
hx_mblock_t_init = _ida_hexrays.hx_mblock_t_init
hx_mblock_t_print = _ida_hexrays.hx_mblock_t_print
hx_mblock_t_dump = _ida_hexrays.hx_mblock_t_dump
hx_mblock_t_vdump_block = _ida_hexrays.hx_mblock_t_vdump_block
hx_mblock_t_insert_into_block = _ida_hexrays.hx_mblock_t_insert_into_block
hx_mblock_t_remove_from_block = _ida_hexrays.hx_mblock_t_remove_from_block
hx_mblock_t_for_all_insns = _ida_hexrays.hx_mblock_t_for_all_insns
hx_mblock_t_for_all_ops = _ida_hexrays.hx_mblock_t_for_all_ops
hx_mblock_t_for_all_uses = _ida_hexrays.hx_mblock_t_for_all_uses
hx_mblock_t_optimize_insn = _ida_hexrays.hx_mblock_t_optimize_insn
hx_mblock_t_optimize_block = _ida_hexrays.hx_mblock_t_optimize_block
hx_mblock_t_build_lists = _ida_hexrays.hx_mblock_t_build_lists
hx_mblock_t_append_use_list = _ida_hexrays.hx_mblock_t_append_use_list
hx_mblock_t_append_def_list = _ida_hexrays.hx_mblock_t_append_def_list
hx_mblock_t_build_use_list = _ida_hexrays.hx_mblock_t_build_use_list
hx_mblock_t_build_def_list = _ida_hexrays.hx_mblock_t_build_def_list
hx_mblock_t_find_first_use = _ida_hexrays.hx_mblock_t_find_first_use
hx_mblock_t_find_redefinition = _ida_hexrays.hx_mblock_t_find_redefinition
hx_mblock_t_is_rhs_redefined = _ida_hexrays.hx_mblock_t_is_rhs_redefined
hx_mblock_t_find_access = _ida_hexrays.hx_mblock_t_find_access
hx_mblock_t_get_valranges = _ida_hexrays.hx_mblock_t_get_valranges
hx_mbl_array_t_idaloc2vd = _ida_hexrays.hx_mbl_array_t_idaloc2vd
hx_mbl_array_t_vd2idaloc = _ida_hexrays.hx_mbl_array_t_vd2idaloc
hx_mbl_array_t_term = _ida_hexrays.hx_mbl_array_t_term
hx_mbl_array_t_optimize_local = _ida_hexrays.hx_mbl_array_t_optimize_local
hx_mbl_array_t_build_graph = _ida_hexrays.hx_mbl_array_t_build_graph
hx_mbl_array_t_get_graph = _ida_hexrays.hx_mbl_array_t_get_graph
hx_mbl_array_t_analyze_calls = _ida_hexrays.hx_mbl_array_t_analyze_calls
hx_mbl_array_t_optimize_global = _ida_hexrays.hx_mbl_array_t_optimize_global
hx_mbl_array_t_alloc_lvars = _ida_hexrays.hx_mbl_array_t_alloc_lvars
hx_mbl_array_t_dump = _ida_hexrays.hx_mbl_array_t_dump
hx_mbl_array_t_vdump_mba = _ida_hexrays.hx_mbl_array_t_vdump_mba
hx_mbl_array_t_print = _ida_hexrays.hx_mbl_array_t_print
hx_mbl_array_t_verify = _ida_hexrays.hx_mbl_array_t_verify
hx_mbl_array_t_mark_chains_dirty = _ida_hexrays.hx_mbl_array_t_mark_chains_dirty
hx_mbl_array_t_insert_block = _ida_hexrays.hx_mbl_array_t_insert_block
hx_mbl_array_t_remove_block = _ida_hexrays.hx_mbl_array_t_remove_block
hx_mbl_array_t_remove_empty_blocks = _ida_hexrays.hx_mbl_array_t_remove_empty_blocks
hx_mbl_array_t_combine_blocks = _ida_hexrays.hx_mbl_array_t_combine_blocks
hx_mbl_array_t_for_all_ops = _ida_hexrays.hx_mbl_array_t_for_all_ops
hx_mbl_array_t_for_all_insns = _ida_hexrays.hx_mbl_array_t_for_all_insns
hx_mbl_array_t_for_all_topinsns = _ida_hexrays.hx_mbl_array_t_for_all_topinsns
hx_mbl_array_t_find_mop = _ida_hexrays.hx_mbl_array_t_find_mop
hx_mbl_array_t_arg = _ida_hexrays.hx_mbl_array_t_arg
hx_mbl_array_t_serialize = _ida_hexrays.hx_mbl_array_t_serialize
hx_mbl_array_t_deserialize = _ida_hexrays.hx_mbl_array_t_deserialize
hx_mbl_graph_t_is_accessed_globally = _ida_hexrays.hx_mbl_graph_t_is_accessed_globally
hx_mbl_graph_t_get_ud = _ida_hexrays.hx_mbl_graph_t_get_ud
hx_mbl_graph_t_get_du = _ida_hexrays.hx_mbl_graph_t_get_du
hx_codegen_t_emit = _ida_hexrays.hx_codegen_t_emit
hx_codegen_t_emit_ = _ida_hexrays.hx_codegen_t_emit_
hx_is_kreg = _ida_hexrays.hx_is_kreg
hx_get_temp_regs = _ida_hexrays.hx_get_temp_regs
hx_get_hexrays_version = _ida_hexrays.hx_get_hexrays_version
hx_open_pseudocode = _ida_hexrays.hx_open_pseudocode
hx_close_pseudocode = _ida_hexrays.hx_close_pseudocode
hx_get_widget_vdui = _ida_hexrays.hx_get_widget_vdui
hx_decompile_many = _ida_hexrays.hx_decompile_many
hx_hexrays_failure_t_desc = _ida_hexrays.hx_hexrays_failure_t_desc
hx_send_database = _ida_hexrays.hx_send_database
hx_gco_info_t_append_to_list = _ida_hexrays.hx_gco_info_t_append_to_list
hx_get_current_operand = _ida_hexrays.hx_get_current_operand
hx_remitem = _ida_hexrays.hx_remitem
hx_negated_relation = _ida_hexrays.hx_negated_relation
hx_swapped_relation = _ida_hexrays.hx_swapped_relation
hx_get_op_signness = _ida_hexrays.hx_get_op_signness
hx_asgop = _ida_hexrays.hx_asgop
hx_asgop_revert = _ida_hexrays.hx_asgop_revert
hx_cnumber_t_print = _ida_hexrays.hx_cnumber_t_print
hx_cnumber_t_value = _ida_hexrays.hx_cnumber_t_value
hx_cnumber_t_assign = _ida_hexrays.hx_cnumber_t_assign
hx_cnumber_t_compare = _ida_hexrays.hx_cnumber_t_compare
hx_var_ref_t_compare = _ida_hexrays.hx_var_ref_t_compare
hx_ctree_visitor_t_apply_to = _ida_hexrays.hx_ctree_visitor_t_apply_to
hx_ctree_visitor_t_apply_to_exprs = _ida_hexrays.hx_ctree_visitor_t_apply_to_exprs
hx_ctree_parentee_t_recalc_parent_types = _ida_hexrays.hx_ctree_parentee_t_recalc_parent_types
hx_cfunc_parentee_t_calc_rvalue_type = _ida_hexrays.hx_cfunc_parentee_t_calc_rvalue_type
hx_citem_locator_t_compare = _ida_hexrays.hx_citem_locator_t_compare
hx_citem_t_contains_expr = _ida_hexrays.hx_citem_t_contains_expr
hx_citem_t_contains_label = _ida_hexrays.hx_citem_t_contains_label
hx_citem_t_find_parent_of = _ida_hexrays.hx_citem_t_find_parent_of
hx_citem_t_find_closest_addr = _ida_hexrays.hx_citem_t_find_closest_addr
hx_cexpr_t_assign = _ida_hexrays.hx_cexpr_t_assign
hx_cexpr_t_compare = _ida_hexrays.hx_cexpr_t_compare
hx_cexpr_t_replace_by = _ida_hexrays.hx_cexpr_t_replace_by
hx_cexpr_t_cleanup = _ida_hexrays.hx_cexpr_t_cleanup
hx_cexpr_t_put_number = _ida_hexrays.hx_cexpr_t_put_number
hx_cexpr_t_print1 = _ida_hexrays.hx_cexpr_t_print1
hx_cexpr_t_calc_type = _ida_hexrays.hx_cexpr_t_calc_type
hx_cexpr_t_equal_effect = _ida_hexrays.hx_cexpr_t_equal_effect
hx_cexpr_t_is_child_of = _ida_hexrays.hx_cexpr_t_is_child_of
hx_cexpr_t_contains_operator = _ida_hexrays.hx_cexpr_t_contains_operator
hx_cexpr_t_get_high_nbit_bound = _ida_hexrays.hx_cexpr_t_get_high_nbit_bound
hx_cexpr_t_get_low_nbit_bound = _ida_hexrays.hx_cexpr_t_get_low_nbit_bound
hx_cexpr_t_requires_lvalue = _ida_hexrays.hx_cexpr_t_requires_lvalue
hx_cexpr_t_has_side_effects = _ida_hexrays.hx_cexpr_t_has_side_effects
hx_cif_t_assign = _ida_hexrays.hx_cif_t_assign
hx_cif_t_compare = _ida_hexrays.hx_cif_t_compare
hx_cloop_t_assign = _ida_hexrays.hx_cloop_t_assign
hx_cfor_t_compare = _ida_hexrays.hx_cfor_t_compare
hx_cwhile_t_compare = _ida_hexrays.hx_cwhile_t_compare
hx_cdo_t_compare = _ida_hexrays.hx_cdo_t_compare
hx_creturn_t_compare = _ida_hexrays.hx_creturn_t_compare
hx_cgoto_t_compare = _ida_hexrays.hx_cgoto_t_compare
hx_casm_t_compare = _ida_hexrays.hx_casm_t_compare
hx_cinsn_t_assign = _ida_hexrays.hx_cinsn_t_assign
hx_cinsn_t_compare = _ida_hexrays.hx_cinsn_t_compare
hx_cinsn_t_replace_by = _ida_hexrays.hx_cinsn_t_replace_by
hx_cinsn_t_cleanup = _ida_hexrays.hx_cinsn_t_cleanup
hx_cinsn_t_new_insn = _ida_hexrays.hx_cinsn_t_new_insn
hx_cinsn_t_create_if = _ida_hexrays.hx_cinsn_t_create_if
hx_cinsn_t_print = _ida_hexrays.hx_cinsn_t_print
hx_cinsn_t_print1 = _ida_hexrays.hx_cinsn_t_print1
hx_cinsn_t_is_ordinary_flow = _ida_hexrays.hx_cinsn_t_is_ordinary_flow
hx_cinsn_t_contains_insn = _ida_hexrays.hx_cinsn_t_contains_insn
hx_cinsn_t_collect_free_breaks = _ida_hexrays.hx_cinsn_t_collect_free_breaks
hx_cinsn_t_collect_free_continues = _ida_hexrays.hx_cinsn_t_collect_free_continues
hx_cblock_t_compare = _ida_hexrays.hx_cblock_t_compare
hx_carglist_t_compare = _ida_hexrays.hx_carglist_t_compare
hx_ccase_t_compare = _ida_hexrays.hx_ccase_t_compare
hx_ccases_t_compare = _ida_hexrays.hx_ccases_t_compare
hx_cswitch_t_compare = _ida_hexrays.hx_cswitch_t_compare
hx_ctree_item_t_get_memptr = _ida_hexrays.hx_ctree_item_t_get_memptr
hx_ctree_item_t_get_lvar = _ida_hexrays.hx_ctree_item_t_get_lvar
hx_ctree_item_t_get_ea = _ida_hexrays.hx_ctree_item_t_get_ea
hx_ctree_item_t_get_label_num = _ida_hexrays.hx_ctree_item_t_get_label_num
hx_lnot = _ida_hexrays.hx_lnot
hx_new_block = _ida_hexrays.hx_new_block
hx_vcreate_helper = _ida_hexrays.hx_vcreate_helper
hx_vcall_helper = _ida_hexrays.hx_vcall_helper
hx_make_num = _ida_hexrays.hx_make_num
hx_make_ref = _ida_hexrays.hx_make_ref
hx_dereference = _ida_hexrays.hx_dereference
hx_save_user_labels = _ida_hexrays.hx_save_user_labels
hx_save_user_cmts = _ida_hexrays.hx_save_user_cmts
hx_save_user_numforms = _ida_hexrays.hx_save_user_numforms
hx_save_user_iflags = _ida_hexrays.hx_save_user_iflags
hx_save_user_unions = _ida_hexrays.hx_save_user_unions
hx_restore_user_labels = _ida_hexrays.hx_restore_user_labels
hx_restore_user_cmts = _ida_hexrays.hx_restore_user_cmts
hx_restore_user_numforms = _ida_hexrays.hx_restore_user_numforms
hx_restore_user_iflags = _ida_hexrays.hx_restore_user_iflags
hx_restore_user_unions = _ida_hexrays.hx_restore_user_unions
hx_cfunc_t_build_c_tree = _ida_hexrays.hx_cfunc_t_build_c_tree
hx_cfunc_t_verify = _ida_hexrays.hx_cfunc_t_verify
hx_cfunc_t_print_dcl = _ida_hexrays.hx_cfunc_t_print_dcl
hx_cfunc_t_print_func = _ida_hexrays.hx_cfunc_t_print_func
hx_cfunc_t_get_func_type = _ida_hexrays.hx_cfunc_t_get_func_type
hx_cfunc_t_get_lvars = _ida_hexrays.hx_cfunc_t_get_lvars
hx_cfunc_t_get_stkoff_delta = _ida_hexrays.hx_cfunc_t_get_stkoff_delta
hx_cfunc_t_find_label = _ida_hexrays.hx_cfunc_t_find_label
hx_cfunc_t_remove_unused_labels = _ida_hexrays.hx_cfunc_t_remove_unused_labels
hx_cfunc_t_get_user_cmt = _ida_hexrays.hx_cfunc_t_get_user_cmt
hx_cfunc_t_set_user_cmt = _ida_hexrays.hx_cfunc_t_set_user_cmt
hx_cfunc_t_get_user_iflags = _ida_hexrays.hx_cfunc_t_get_user_iflags
hx_cfunc_t_set_user_iflags = _ida_hexrays.hx_cfunc_t_set_user_iflags
hx_cfunc_t_has_orphan_cmts = _ida_hexrays.hx_cfunc_t_has_orphan_cmts
hx_cfunc_t_del_orphan_cmts = _ida_hexrays.hx_cfunc_t_del_orphan_cmts
hx_cfunc_t_get_user_union_selection = _ida_hexrays.hx_cfunc_t_get_user_union_selection
hx_cfunc_t_set_user_union_selection = _ida_hexrays.hx_cfunc_t_set_user_union_selection
hx_cfunc_t_get_line_item = _ida_hexrays.hx_cfunc_t_get_line_item
hx_cfunc_t_get_warnings = _ida_hexrays.hx_cfunc_t_get_warnings
hx_cfunc_t_get_eamap = _ida_hexrays.hx_cfunc_t_get_eamap
hx_cfunc_t_get_boundaries = _ida_hexrays.hx_cfunc_t_get_boundaries
hx_cfunc_t_get_pseudocode = _ida_hexrays.hx_cfunc_t_get_pseudocode
hx_cfunc_t_gather_derefs = _ida_hexrays.hx_cfunc_t_gather_derefs
hx_cfunc_t_find_item_coords = _ida_hexrays.hx_cfunc_t_find_item_coords
hx_cfunc_t_cleanup = _ida_hexrays.hx_cfunc_t_cleanup
hx_decompile = _ida_hexrays.hx_decompile
hx_gen_microcode = _ida_hexrays.hx_gen_microcode
hx_mark_cfunc_dirty = _ida_hexrays.hx_mark_cfunc_dirty
hx_clear_cached_cfuncs = _ida_hexrays.hx_clear_cached_cfuncs
hx_has_cached_cfunc = _ida_hexrays.hx_has_cached_cfunc
hx_get_ctype_name = _ida_hexrays.hx_get_ctype_name
hx_create_field_name = _ida_hexrays.hx_create_field_name
hx_install_hexrays_callback = _ida_hexrays.hx_install_hexrays_callback
hx_remove_hexrays_callback = _ida_hexrays.hx_remove_hexrays_callback
hx_vdui_t_set_locked = _ida_hexrays.hx_vdui_t_set_locked
hx_vdui_t_refresh_view = _ida_hexrays.hx_vdui_t_refresh_view
hx_vdui_t_refresh_ctext = _ida_hexrays.hx_vdui_t_refresh_ctext
hx_vdui_t_switch_to = _ida_hexrays.hx_vdui_t_switch_to
hx_vdui_t_get_number = _ida_hexrays.hx_vdui_t_get_number
hx_vdui_t_get_current_label = _ida_hexrays.hx_vdui_t_get_current_label
hx_vdui_t_clear = _ida_hexrays.hx_vdui_t_clear
hx_vdui_t_refresh_cpos = _ida_hexrays.hx_vdui_t_refresh_cpos
hx_vdui_t_get_current_item = _ida_hexrays.hx_vdui_t_get_current_item
hx_vdui_t_ui_rename_lvar = _ida_hexrays.hx_vdui_t_ui_rename_lvar
hx_vdui_t_rename_lvar = _ida_hexrays.hx_vdui_t_rename_lvar
hx_vdui_t_ui_set_call_type = _ida_hexrays.hx_vdui_t_ui_set_call_type
hx_vdui_t_ui_set_lvar_type = _ida_hexrays.hx_vdui_t_ui_set_lvar_type
hx_vdui_t_set_lvar_type = _ida_hexrays.hx_vdui_t_set_lvar_type
hx_vdui_t_ui_edit_lvar_cmt = _ida_hexrays.hx_vdui_t_ui_edit_lvar_cmt
hx_vdui_t_set_lvar_cmt = _ida_hexrays.hx_vdui_t_set_lvar_cmt
hx_vdui_t_ui_map_lvar = _ida_hexrays.hx_vdui_t_ui_map_lvar
hx_vdui_t_ui_unmap_lvar = _ida_hexrays.hx_vdui_t_ui_unmap_lvar
hx_vdui_t_map_lvar = _ida_hexrays.hx_vdui_t_map_lvar
hx_vdui_t_set_strmem_type = _ida_hexrays.hx_vdui_t_set_strmem_type
hx_vdui_t_rename_strmem = _ida_hexrays.hx_vdui_t_rename_strmem
hx_vdui_t_set_global_type = _ida_hexrays.hx_vdui_t_set_global_type
hx_vdui_t_rename_global = _ida_hexrays.hx_vdui_t_rename_global
hx_vdui_t_rename_label = _ida_hexrays.hx_vdui_t_rename_label
hx_vdui_t_jump_enter = _ida_hexrays.hx_vdui_t_jump_enter
hx_vdui_t_ctree_to_disasm = _ida_hexrays.hx_vdui_t_ctree_to_disasm
hx_vdui_t_calc_cmt_type = _ida_hexrays.hx_vdui_t_calc_cmt_type
hx_vdui_t_edit_cmt = _ida_hexrays.hx_vdui_t_edit_cmt
hx_vdui_t_edit_func_cmt = _ida_hexrays.hx_vdui_t_edit_func_cmt
hx_vdui_t_del_orphan_cmts = _ida_hexrays.hx_vdui_t_del_orphan_cmts
hx_vdui_t_set_num_radix = _ida_hexrays.hx_vdui_t_set_num_radix
hx_vdui_t_set_num_enum = _ida_hexrays.hx_vdui_t_set_num_enum
hx_vdui_t_set_num_stroff = _ida_hexrays.hx_vdui_t_set_num_stroff
hx_vdui_t_invert_sign = _ida_hexrays.hx_vdui_t_invert_sign
hx_vdui_t_invert_bits = _ida_hexrays.hx_vdui_t_invert_bits
hx_vdui_t_collapse_item = _ida_hexrays.hx_vdui_t_collapse_item
hx_vdui_t_collapse_lvars = _ida_hexrays.hx_vdui_t_collapse_lvars
hx_vdui_t_split_item = _ida_hexrays.hx_vdui_t_split_item
hx_hexrays_alloc = _ida_hexrays.hx_hexrays_alloc
hx_hexrays_free = _ida_hexrays.hx_hexrays_free
hx_vdui_t_set_noptr_lvar = _ida_hexrays.hx_vdui_t_set_noptr_lvar
class user_numforms_iterator_t(object):
    """
    Proxy of C++ user_numforms_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_numforms_iterator_t_x_get, _ida_hexrays.user_numforms_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_numforms_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_numforms_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_numforms_iterator_t
        """
        this = _ida_hexrays.new_user_numforms_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_numforms_iterator_t
    __del__ = lambda self : None;
user_numforms_iterator_t_swigregister = _ida_hexrays.user_numforms_iterator_t_swigregister
user_numforms_iterator_t_swigregister(user_numforms_iterator_t)


def user_numforms_begin(*args):
  """
  user_numforms_begin(map) -> user_numforms_iterator_t


  Get iterator pointing to the beginning of user_numforms_t.
  
  
  @param map (C++: const user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_begin(*args)

def user_numforms_end(*args):
  """
  user_numforms_end(map) -> user_numforms_iterator_t


  Get iterator pointing to the end of user_numforms_t.
  
  
  @param map (C++: const user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_end(*args)

def user_numforms_next(*args):
  """
  user_numforms_next(p) -> user_numforms_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_next(*args)

def user_numforms_prev(*args):
  """
  user_numforms_prev(p) -> user_numforms_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_prev(*args)

def user_numforms_first(*args):
  """
  user_numforms_first(p) -> operand_locator_t


  Get reference to the current map key.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_first(*args)

def user_numforms_second(*args):
  """
  user_numforms_second(p) -> number_format_t


  Get reference to the current map value.
  
  
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_second(*args)

def user_numforms_find(*args):
  """
  user_numforms_find(map, key) -> user_numforms_iterator_t


  Find the specified key in user_numforms_t.
  
  
  @param map (C++: const user_numforms_t *)
  @param key (C++: const  operand_locator_t  &)
  """
  return _ida_hexrays.user_numforms_find(*args)

def user_numforms_insert(*args):
  """
  user_numforms_insert(map, key, val) -> user_numforms_iterator_t


  Insert new ( 'operand_locator_t' , 'number_format_t' ) pair into
  user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  @param key (C++: const  operand_locator_t  &)
  @param val (C++: const  number_format_t  &)
  """
  return _ida_hexrays.user_numforms_insert(*args)

def user_numforms_erase(*args):
  """
  user_numforms_erase(map, p)


  Erase current element from user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  @param p (C++: user_numforms_iterator_t)
  """
  return _ida_hexrays.user_numforms_erase(*args)

def user_numforms_clear(*args):
  """
  user_numforms_clear(map)


  Clear user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_clear(*args)

def user_numforms_size(*args):
  """
  user_numforms_size(map) -> size_t


  Get size of user_numforms_t.
  
  
  @param map (C++: user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_size(*args)

def user_numforms_free(*args):
  """
  user_numforms_free(map)


  Delete user_numforms_t instance.
  
  
  @param map (C++: user_numforms_t *)
  """
  return _ida_hexrays.user_numforms_free(*args)

def user_numforms_new(*args):
  """
  user_numforms_new() -> user_numforms_t


  Create a new user_numforms_t instance.
  """
  return _ida_hexrays.user_numforms_new(*args)
class lvar_mapping_iterator_t(object):
    """
    Proxy of C++ lvar_mapping_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.lvar_mapping_iterator_t_x_get, _ida_hexrays.lvar_mapping_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.lvar_mapping_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.lvar_mapping_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> lvar_mapping_iterator_t
        """
        this = _ida_hexrays.new_lvar_mapping_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_lvar_mapping_iterator_t
    __del__ = lambda self : None;
lvar_mapping_iterator_t_swigregister = _ida_hexrays.lvar_mapping_iterator_t_swigregister
lvar_mapping_iterator_t_swigregister(lvar_mapping_iterator_t)


def lvar_mapping_begin(*args):
  """
  lvar_mapping_begin(map) -> lvar_mapping_iterator_t


  Get iterator pointing to the beginning of lvar_mapping_t.
  
  
  @param map (C++: const lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_begin(*args)

def lvar_mapping_end(*args):
  """
  lvar_mapping_end(map) -> lvar_mapping_iterator_t


  Get iterator pointing to the end of lvar_mapping_t.
  
  
  @param map (C++: const lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_end(*args)

def lvar_mapping_next(*args):
  """
  lvar_mapping_next(p) -> lvar_mapping_iterator_t


  Move to the next element.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_next(*args)

def lvar_mapping_prev(*args):
  """
  lvar_mapping_prev(p) -> lvar_mapping_iterator_t


  Move to the previous element.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_prev(*args)

def lvar_mapping_first(*args):
  """
  lvar_mapping_first(p) -> lvar_locator_t


  Get reference to the current map key.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_first(*args)

def lvar_mapping_second(*args):
  """
  lvar_mapping_second(p) -> lvar_locator_t


  Get reference to the current map value.
  
  
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_second(*args)

def lvar_mapping_find(*args):
  """
  lvar_mapping_find(map, key) -> lvar_mapping_iterator_t


  Find the specified key in lvar_mapping_t.
  
  
  @param map (C++: const lvar_mapping_t *)
  @param key (C++: const  lvar_locator_t  &)
  """
  return _ida_hexrays.lvar_mapping_find(*args)

def lvar_mapping_insert(*args):
  """
  lvar_mapping_insert(map, key, val) -> lvar_mapping_iterator_t


  Insert new ( 'lvar_locator_t' , 'lvar_locator_t' ) pair into
  lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  @param key (C++: const  lvar_locator_t  &)
  @param val (C++: const  lvar_locator_t  &)
  """
  return _ida_hexrays.lvar_mapping_insert(*args)

def lvar_mapping_erase(*args):
  """
  lvar_mapping_erase(map, p)


  Erase current element from lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  @param p (C++: lvar_mapping_iterator_t)
  """
  return _ida_hexrays.lvar_mapping_erase(*args)

def lvar_mapping_clear(*args):
  """
  lvar_mapping_clear(map)


  Clear lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_clear(*args)

def lvar_mapping_size(*args):
  """
  lvar_mapping_size(map) -> size_t


  Get size of lvar_mapping_t.
  
  
  @param map (C++: lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_size(*args)

def lvar_mapping_free(*args):
  """
  lvar_mapping_free(map)


  Delete lvar_mapping_t instance.
  
  
  @param map (C++: lvar_mapping_t *)
  """
  return _ida_hexrays.lvar_mapping_free(*args)

def lvar_mapping_new(*args):
  """
  lvar_mapping_new() -> lvar_mapping_t


  Create a new lvar_mapping_t instance.
  """
  return _ida_hexrays.lvar_mapping_new(*args)
class udcall_map_iterator_t(object):
    """
    Proxy of C++ udcall_map_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.udcall_map_iterator_t_x_get, _ida_hexrays.udcall_map_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.udcall_map_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.udcall_map_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> udcall_map_iterator_t
        """
        this = _ida_hexrays.new_udcall_map_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_udcall_map_iterator_t
    __del__ = lambda self : None;
udcall_map_iterator_t_swigregister = _ida_hexrays.udcall_map_iterator_t_swigregister
udcall_map_iterator_t_swigregister(udcall_map_iterator_t)


def udcall_map_begin(*args):
  """
  udcall_map_begin(map) -> udcall_map_iterator_t


  Get iterator pointing to the beginning of udcall_map_t.
  
  
  @param map (C++: const udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_begin(*args)

def udcall_map_end(*args):
  """
  udcall_map_end(map) -> udcall_map_iterator_t


  Get iterator pointing to the end of udcall_map_t.
  
  
  @param map (C++: const udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_end(*args)

def udcall_map_next(*args):
  """
  udcall_map_next(p) -> udcall_map_iterator_t


  Move to the next element.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_next(*args)

def udcall_map_prev(*args):
  """
  udcall_map_prev(p) -> udcall_map_iterator_t


  Move to the previous element.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_prev(*args)

def udcall_map_first(*args):
  """
  udcall_map_first(p) -> ea_t const &


  Get reference to the current map key.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_first(*args)

def udcall_map_second(*args):
  """
  udcall_map_second(p) -> udcall_t


  Get reference to the current map value.
  
  
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_second(*args)

def udcall_map_find(*args):
  """
  udcall_map_find(map, key) -> udcall_map_iterator_t


  Find the specified key in udcall_map_t.
  
  
  @param map (C++: const udcall_map_t *)
  @param key (C++: const ea_t &)
  """
  return _ida_hexrays.udcall_map_find(*args)

def udcall_map_insert(*args):
  """
  udcall_map_insert(map, key, val) -> udcall_map_iterator_t


  Insert new (ea_t, 'udcall_t' ) pair into udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  @param key (C++: const ea_t &)
  @param val (C++: const  udcall_t  &)
  """
  return _ida_hexrays.udcall_map_insert(*args)

def udcall_map_erase(*args):
  """
  udcall_map_erase(map, p)


  Erase current element from udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  @param p (C++: udcall_map_iterator_t)
  """
  return _ida_hexrays.udcall_map_erase(*args)

def udcall_map_clear(*args):
  """
  udcall_map_clear(map)


  Clear udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_clear(*args)

def udcall_map_size(*args):
  """
  udcall_map_size(map) -> size_t


  Get size of udcall_map_t.
  
  
  @param map (C++: udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_size(*args)

def udcall_map_free(*args):
  """
  udcall_map_free(map)


  Delete udcall_map_t instance.
  
  
  @param map (C++: udcall_map_t *)
  """
  return _ida_hexrays.udcall_map_free(*args)

def udcall_map_new(*args):
  """
  udcall_map_new() -> udcall_map_t *


  Create a new udcall_map_t instance.
  """
  return _ida_hexrays.udcall_map_new(*args)
class user_cmts_iterator_t(object):
    """
    Proxy of C++ user_cmts_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_cmts_iterator_t_x_get, _ida_hexrays.user_cmts_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_cmts_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_cmts_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_cmts_iterator_t
        """
        this = _ida_hexrays.new_user_cmts_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_cmts_iterator_t
    __del__ = lambda self : None;
user_cmts_iterator_t_swigregister = _ida_hexrays.user_cmts_iterator_t_swigregister
user_cmts_iterator_t_swigregister(user_cmts_iterator_t)


def user_cmts_begin(*args):
  """
  user_cmts_begin(map) -> user_cmts_iterator_t


  Get iterator pointing to the beginning of user_cmts_t.
  
  
  @param map (C++: const user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_begin(*args)

def user_cmts_end(*args):
  """
  user_cmts_end(map) -> user_cmts_iterator_t


  Get iterator pointing to the end of user_cmts_t.
  
  
  @param map (C++: const user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_end(*args)

def user_cmts_next(*args):
  """
  user_cmts_next(p) -> user_cmts_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_next(*args)

def user_cmts_prev(*args):
  """
  user_cmts_prev(p) -> user_cmts_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_prev(*args)

def user_cmts_first(*args):
  """
  user_cmts_first(p) -> treeloc_t


  Get reference to the current map key.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_first(*args)

def user_cmts_second(*args):
  """
  user_cmts_second(p) -> citem_cmt_t


  Get reference to the current map value.
  
  
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_second(*args)

def user_cmts_find(*args):
  """
  user_cmts_find(map, key) -> user_cmts_iterator_t


  Find the specified key in user_cmts_t.
  
  
  @param map (C++: const user_cmts_t *)
  @param key (C++: const  treeloc_t  &)
  """
  return _ida_hexrays.user_cmts_find(*args)

def user_cmts_insert(*args):
  """
  user_cmts_insert(map, key, val) -> user_cmts_iterator_t


  Insert new ( 'treeloc_t' , 'citem_cmt_t' ) pair into user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  @param key (C++: const  treeloc_t  &)
  @param val (C++: const  citem_cmt_t  &)
  """
  return _ida_hexrays.user_cmts_insert(*args)

def user_cmts_erase(*args):
  """
  user_cmts_erase(map, p)


  Erase current element from user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  @param p (C++: user_cmts_iterator_t)
  """
  return _ida_hexrays.user_cmts_erase(*args)

def user_cmts_clear(*args):
  """
  user_cmts_clear(map)


  Clear user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_clear(*args)

def user_cmts_size(*args):
  """
  user_cmts_size(map) -> size_t


  Get size of user_cmts_t.
  
  
  @param map (C++: user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_size(*args)

def user_cmts_free(*args):
  """
  user_cmts_free(map)


  Delete user_cmts_t instance.
  
  
  @param map (C++: user_cmts_t *)
  """
  return _ida_hexrays.user_cmts_free(*args)

def user_cmts_new(*args):
  """
  user_cmts_new() -> user_cmts_t


  Create a new user_cmts_t instance.
  """
  return _ida_hexrays.user_cmts_new(*args)
class user_iflags_iterator_t(object):
    """
    Proxy of C++ user_iflags_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_iflags_iterator_t_x_get, _ida_hexrays.user_iflags_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_iflags_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_iflags_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_iflags_iterator_t
        """
        this = _ida_hexrays.new_user_iflags_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_iflags_iterator_t
    __del__ = lambda self : None;
user_iflags_iterator_t_swigregister = _ida_hexrays.user_iflags_iterator_t_swigregister
user_iflags_iterator_t_swigregister(user_iflags_iterator_t)


def user_iflags_begin(*args):
  """
  user_iflags_begin(map) -> user_iflags_iterator_t


  Get iterator pointing to the beginning of user_iflags_t.
  
  
  @param map (C++: const user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_begin(*args)

def user_iflags_end(*args):
  """
  user_iflags_end(map) -> user_iflags_iterator_t


  Get iterator pointing to the end of user_iflags_t.
  
  
  @param map (C++: const user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_end(*args)

def user_iflags_next(*args):
  """
  user_iflags_next(p) -> user_iflags_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_next(*args)

def user_iflags_prev(*args):
  """
  user_iflags_prev(p) -> user_iflags_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_prev(*args)

def user_iflags_first(*args):
  """
  user_iflags_first(p) -> citem_locator_t


  Get reference to the current map key.
  
  
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_first(*args)

def user_iflags_find(*args):
  """
  user_iflags_find(map, key) -> user_iflags_iterator_t


  Find the specified key in user_iflags_t.
  
  
  @param map (C++: const user_iflags_t *)
  @param key (C++: const  citem_locator_t  &)
  """
  return _ida_hexrays.user_iflags_find(*args)

def user_iflags_insert(*args):
  """
  user_iflags_insert(map, key, val) -> user_iflags_iterator_t


  Insert new ( 'citem_locator_t' , int32) pair into user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  @param key (C++: const  citem_locator_t  &)
  @param val (C++: const  int32  &)
  """
  return _ida_hexrays.user_iflags_insert(*args)

def user_iflags_erase(*args):
  """
  user_iflags_erase(map, p)


  Erase current element from user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  @param p (C++: user_iflags_iterator_t)
  """
  return _ida_hexrays.user_iflags_erase(*args)

def user_iflags_clear(*args):
  """
  user_iflags_clear(map)


  Clear user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_clear(*args)

def user_iflags_size(*args):
  """
  user_iflags_size(map) -> size_t


  Get size of user_iflags_t.
  
  
  @param map (C++: user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_size(*args)

def user_iflags_free(*args):
  """
  user_iflags_free(map)


  Delete user_iflags_t instance.
  
  
  @param map (C++: user_iflags_t *)
  """
  return _ida_hexrays.user_iflags_free(*args)

def user_iflags_new(*args):
  """
  user_iflags_new() -> user_iflags_t


  Create a new user_iflags_t instance.
  """
  return _ida_hexrays.user_iflags_new(*args)
class user_unions_iterator_t(object):
    """
    Proxy of C++ user_unions_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_unions_iterator_t_x_get, _ida_hexrays.user_unions_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_unions_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_unions_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_unions_iterator_t
        """
        this = _ida_hexrays.new_user_unions_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_unions_iterator_t
    __del__ = lambda self : None;
user_unions_iterator_t_swigregister = _ida_hexrays.user_unions_iterator_t_swigregister
user_unions_iterator_t_swigregister(user_unions_iterator_t)


def user_unions_begin(*args):
  """
  user_unions_begin(map) -> user_unions_iterator_t


  Get iterator pointing to the beginning of user_unions_t.
  
  
  @param map (C++: const user_unions_t *)
  """
  return _ida_hexrays.user_unions_begin(*args)

def user_unions_end(*args):
  """
  user_unions_end(map) -> user_unions_iterator_t


  Get iterator pointing to the end of user_unions_t.
  
  
  @param map (C++: const user_unions_t *)
  """
  return _ida_hexrays.user_unions_end(*args)

def user_unions_next(*args):
  """
  user_unions_next(p) -> user_unions_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_next(*args)

def user_unions_prev(*args):
  """
  user_unions_prev(p) -> user_unions_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_prev(*args)

def user_unions_first(*args):
  """
  user_unions_first(p) -> ea_t const &


  Get reference to the current map key.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_first(*args)

def user_unions_second(*args):
  """
  user_unions_second(p) -> intvec_t &


  Get reference to the current map value.
  
  
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_second(*args)

def user_unions_find(*args):
  """
  user_unions_find(map, key) -> user_unions_iterator_t


  Find the specified key in user_unions_t.
  
  
  @param map (C++: const user_unions_t *)
  @param key (C++: const ea_t &)
  """
  return _ida_hexrays.user_unions_find(*args)

def user_unions_insert(*args):
  """
  user_unions_insert(map, key, val) -> user_unions_iterator_t


  Insert new (ea_t, intvec_t) pair into user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  @param key (C++: const ea_t &)
  @param val (C++: const  intvec_t  &)
  """
  return _ida_hexrays.user_unions_insert(*args)

def user_unions_erase(*args):
  """
  user_unions_erase(map, p)


  Erase current element from user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  @param p (C++: user_unions_iterator_t)
  """
  return _ida_hexrays.user_unions_erase(*args)

def user_unions_clear(*args):
  """
  user_unions_clear(map)


  Clear user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  """
  return _ida_hexrays.user_unions_clear(*args)

def user_unions_size(*args):
  """
  user_unions_size(map) -> size_t


  Get size of user_unions_t.
  
  
  @param map (C++: user_unions_t *)
  """
  return _ida_hexrays.user_unions_size(*args)

def user_unions_free(*args):
  """
  user_unions_free(map)


  Delete user_unions_t instance.
  
  
  @param map (C++: user_unions_t *)
  """
  return _ida_hexrays.user_unions_free(*args)

def user_unions_new(*args):
  """
  user_unions_new() -> user_unions_t


  Create a new user_unions_t instance.
  """
  return _ida_hexrays.user_unions_new(*args)
class user_labels_iterator_t(object):
    """
    Proxy of C++ user_labels_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.user_labels_iterator_t_x_get, _ida_hexrays.user_labels_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.user_labels_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.user_labels_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> user_labels_iterator_t
        """
        this = _ida_hexrays.new_user_labels_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_user_labels_iterator_t
    __del__ = lambda self : None;
user_labels_iterator_t_swigregister = _ida_hexrays.user_labels_iterator_t_swigregister
user_labels_iterator_t_swigregister(user_labels_iterator_t)


def user_labels_begin(*args):
  """
  user_labels_begin(map) -> user_labels_iterator_t


  Get iterator pointing to the beginning of user_labels_t.
  
  
  @param map (C++: const user_labels_t *)
  """
  return _ida_hexrays.user_labels_begin(*args)

def user_labels_end(*args):
  """
  user_labels_end(map) -> user_labels_iterator_t


  Get iterator pointing to the end of user_labels_t.
  
  
  @param map (C++: const user_labels_t *)
  """
  return _ida_hexrays.user_labels_end(*args)

def user_labels_next(*args):
  """
  user_labels_next(p) -> user_labels_iterator_t


  Move to the next element.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_next(*args)

def user_labels_prev(*args):
  """
  user_labels_prev(p) -> user_labels_iterator_t


  Move to the previous element.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_prev(*args)

def user_labels_first(*args):
  """
  user_labels_first(p) -> int const &


  Get reference to the current map key.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_first(*args)

def user_labels_second(*args):
  """
  user_labels_second(p) -> qstring &


  Get reference to the current map value.
  
  
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_second(*args)

def user_labels_find(*args):
  """
  user_labels_find(map, key) -> user_labels_iterator_t


  Find the specified key in user_labels_t.
  
  
  @param map (C++: const user_labels_t *)
  @param key (C++: const int &)
  """
  return _ida_hexrays.user_labels_find(*args)

def user_labels_insert(*args):
  """
  user_labels_insert(map, key, val) -> user_labels_iterator_t


  Insert new (int, qstring) pair into user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  @param key (C++: const int &)
  @param val (C++: const  qstring  &)
  """
  return _ida_hexrays.user_labels_insert(*args)

def user_labels_erase(*args):
  """
  user_labels_erase(map, p)


  Erase current element from user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  @param p (C++: user_labels_iterator_t)
  """
  return _ida_hexrays.user_labels_erase(*args)

def user_labels_clear(*args):
  """
  user_labels_clear(map)


  Clear user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  """
  return _ida_hexrays.user_labels_clear(*args)

def user_labels_size(*args):
  """
  user_labels_size(map) -> size_t


  Get size of user_labels_t.
  
  
  @param map (C++: user_labels_t *)
  """
  return _ida_hexrays.user_labels_size(*args)

def user_labels_free(*args):
  """
  user_labels_free(map)


  Delete user_labels_t instance.
  
  
  @param map (C++: user_labels_t *)
  """
  return _ida_hexrays.user_labels_free(*args)

def user_labels_new(*args):
  """
  user_labels_new() -> user_labels_t


  Create a new user_labels_t instance.
  """
  return _ida_hexrays.user_labels_new(*args)
class eamap_iterator_t(object):
    """
    Proxy of C++ eamap_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.eamap_iterator_t_x_get, _ida_hexrays.eamap_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.eamap_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.eamap_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> eamap_iterator_t
        """
        this = _ida_hexrays.new_eamap_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_eamap_iterator_t
    __del__ = lambda self : None;
eamap_iterator_t_swigregister = _ida_hexrays.eamap_iterator_t_swigregister
eamap_iterator_t_swigregister(eamap_iterator_t)


def eamap_begin(*args):
  """
  eamap_begin(map) -> eamap_iterator_t


  Get iterator pointing to the beginning of eamap_t.
  
  
  @param map (C++: const eamap_t *)
  """
  return _ida_hexrays.eamap_begin(*args)

def eamap_end(*args):
  """
  eamap_end(map) -> eamap_iterator_t


  Get iterator pointing to the end of eamap_t.
  
  
  @param map (C++: const eamap_t *)
  """
  return _ida_hexrays.eamap_end(*args)

def eamap_next(*args):
  """
  eamap_next(p) -> eamap_iterator_t


  Move to the next element.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_next(*args)

def eamap_prev(*args):
  """
  eamap_prev(p) -> eamap_iterator_t


  Move to the previous element.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_prev(*args)

def eamap_first(*args):
  """
  eamap_first(p) -> ea_t const &


  Get reference to the current map key.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_first(*args)

def eamap_second(*args):
  """
  eamap_second(p) -> cinsnptrvec_t


  Get reference to the current map value.
  
  
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_second(*args)

def eamap_find(*args):
  """
  eamap_find(map, key) -> eamap_iterator_t


  Find the specified key in eamap_t.
  
  
  @param map (C++: const eamap_t *)
  @param key (C++: const ea_t &)
  """
  return _ida_hexrays.eamap_find(*args)

def eamap_insert(*args):
  """
  eamap_insert(map, key, val) -> eamap_iterator_t


  Insert new (ea_t, cinsnptrvec_t) pair into eamap_t.
  
  
  @param map (C++: eamap_t *)
  @param key (C++: const ea_t &)
  @param val (C++: const  cinsnptrvec_t  &)
  """
  return _ida_hexrays.eamap_insert(*args)

def eamap_erase(*args):
  """
  eamap_erase(map, p)


  Erase current element from eamap_t.
  
  
  @param map (C++: eamap_t *)
  @param p (C++: eamap_iterator_t)
  """
  return _ida_hexrays.eamap_erase(*args)

def eamap_clear(*args):
  """
  eamap_clear(map)


  Clear eamap_t.
  
  
  @param map (C++: eamap_t *)
  """
  return _ida_hexrays.eamap_clear(*args)

def eamap_size(*args):
  """
  eamap_size(map) -> size_t


  Get size of eamap_t.
  
  
  @param map (C++: eamap_t *)
  """
  return _ida_hexrays.eamap_size(*args)

def eamap_free(*args):
  """
  eamap_free(map)


  Delete eamap_t instance.
  
  
  @param map (C++: eamap_t *)
  """
  return _ida_hexrays.eamap_free(*args)

def eamap_new(*args):
  """
  eamap_new() -> eamap_t


  Create a new eamap_t instance.
  """
  return _ida_hexrays.eamap_new(*args)
class boundaries_iterator_t(object):
    """
    Proxy of C++ boundaries_iterator_t class
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    x = _swig_property(_ida_hexrays.boundaries_iterator_t_x_get, _ida_hexrays.boundaries_iterator_t_x_set)
    def __eq__(self, *args):
        """
        __eq__(self, p) -> bool
        """
        return _ida_hexrays.boundaries_iterator_t___eq__(self, *args)

    def __ne__(self, *args):
        """
        __ne__(self, p) -> bool
        """
        return _ida_hexrays.boundaries_iterator_t___ne__(self, *args)

    def __init__(self, *args):
        """
        __init__(self) -> boundaries_iterator_t
        """
        this = _ida_hexrays.new_boundaries_iterator_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _ida_hexrays.delete_boundaries_iterator_t
    __del__ = lambda self : None;
boundaries_iterator_t_swigregister = _ida_hexrays.boundaries_iterator_t_swigregister
boundaries_iterator_t_swigregister(boundaries_iterator_t)


def boundaries_begin(*args):
  """
  boundaries_begin(map) -> boundaries_iterator_t


  Get iterator pointing to the beginning of boundaries_t.
  
  
  @param map (C++: const boundaries_t *)
  """
  return _ida_hexrays.boundaries_begin(*args)

def boundaries_end(*args):
  """
  boundaries_end(map) -> boundaries_iterator_t


  Get iterator pointing to the end of boundaries_t.
  
  
  @param map (C++: const boundaries_t *)
  """
  return _ida_hexrays.boundaries_end(*args)

def boundaries_next(*args):
  """
  boundaries_next(p) -> boundaries_iterator_t


  Move to the next element.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_next(*args)

def boundaries_prev(*args):
  """
  boundaries_prev(p) -> boundaries_iterator_t


  Move to the previous element.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_prev(*args)

def boundaries_first(*args):
  """
  boundaries_first(p) -> cinsn_t


  Get reference to the current map key.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_first(*args)

def boundaries_second(*args):
  """
  boundaries_second(p) -> rangeset_t


  Get reference to the current map value.
  
  
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_second(*args)

def boundaries_erase(*args):
  """
  boundaries_erase(map, p)


  Erase current element from boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  @param p (C++: boundaries_iterator_t)
  """
  return _ida_hexrays.boundaries_erase(*args)

def boundaries_clear(*args):
  """
  boundaries_clear(map)


  Clear boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  """
  return _ida_hexrays.boundaries_clear(*args)

def boundaries_size(*args):
  """
  boundaries_size(map) -> size_t


  Get size of boundaries_t.
  
  
  @param map (C++: boundaries_t *)
  """
  return _ida_hexrays.boundaries_size(*args)

def boundaries_free(*args):
  """
  boundaries_free(map)


  Delete boundaries_t instance.
  
  
  @param map (C++: boundaries_t *)
  """
  return _ida_hexrays.boundaries_free(*args)

def boundaries_new(*args):
  """
  boundaries_new() -> boundaries_t


  Create a new boundaries_t instance.
  """
  return _ida_hexrays.boundaries_new(*args)
#<pycode(py_hexrays)>
import ida_funcs

hexrays_failure_t.__str__ = lambda self: str(self.str)

# ---------------------------------------------------------------------
class DecompilationFailure(Exception):
    """
     Raised on a decompilation error.

    The associated hexrays_failure_t object is stored in the
    'info' member of this exception. 
"""

    def __init__(self, info):
        Exception.__init__(self, 'Decompilation failed: %s' % (str(info), ))
        self.info = info
        return

# ---------------------------------------------------------------------
def decompile(ea, hf=None):
    if isinstance(ea, (int, long)):
        func = ida_funcs.get_func(ea)
        if not func: return
    elif type(ea) == ida_funcs.func_t:
        func = ea
    else:
        raise RuntimeError('arg 1 of decompile expects either ea_t or cfunc_t argument')

    if hf is None:
        hf = hexrays_failure_t()

    ptr = _decompile(func, hf)

    if ptr.__deref__() is None:
        raise DecompilationFailure(hf)

    return ptr

# ---------------------------------------------------------------------
# stringify all string types
#qtype.__str__ = qtype.c_str
#qstring.__str__ = qstring.c_str
#citem_cmt_t.__str__ = citem_cmt_t.c_str

# ---------------------------------------------------------------------
# listify all list types
import ida_idaapi
ida_idaapi._listify_types(
        cinsnptrvec_t,
        ctree_items_t,
        qvector_lvar_t,
        qvector_carg_t,
        qvector_ccase_t,
        hexwarns_t,
        history_t,
        lvar_saved_infos_t)

def citem_to_specific_type(self):
    """
     cast the citem_t object to its more specific type, either cexpr_t or cinsn_t. 
    """

    if self.op >= cot_empty and self.op <= cot_last:
        return self.cexpr
    elif self.op >= cit_empty and self.op < cit_end:
        return self.cinsn

    raise RuntimeError('unknown op type %s' % (repr(self.op), ))
citem_t.to_specific_type = property(citem_to_specific_type)

"""
 array used for translating cinsn_t->op type to their names. 
"""
cinsn_t.op_to_typename = {}
for k in dir(_ida_hexrays):
    if k.startswith('cit_'):
        cinsn_t.op_to_typename[getattr(_ida_hexrays, k)] = k[4:]

"""
 array used for translating cexpr_t->op type to their names. 
"""
cexpr_t.op_to_typename = {}
for k in dir(_ida_hexrays):
    if k.startswith('cot_'):
        cexpr_t.op_to_typename[getattr(_ida_hexrays, k)] = k[4:]

def property_op_to_typename(self):
    return self.op_to_typename[self.op]
cinsn_t.opname = property(property_op_to_typename)
cexpr_t.opname = property(property_op_to_typename)

def cexpr_operands(self):
    """
     return a dictionary with the operands of a cexpr_t. 
    """

    if self.op >= cot_comma and self.op <= cot_asgumod or \
        self.op >= cot_lor and self.op <= cot_fdiv or \
        self.op == cot_idx:
        return {'x': self.x, 'y': self.y}

    elif self.op == cot_tern:
        return {'x': self.x, 'y': self.y, 'z': self.z}

    elif self.op in [cot_fneg, cot_neg, cot_sizeof] or \
        self.op >= cot_lnot and self.op <= cot_predec:
        return {'x': self.x}

    elif self.op == cot_cast:
        return {'type': self.type, 'x': self.x}

    elif self.op == cot_call:
        return {'x': self.x, 'a': self.a}

    elif self.op in [cot_memref, cot_memptr]:
        return {'x': self.x, 'm': self.m}

    elif self.op == cot_num:
        return {'n': self.n}

    elif self.op == cot_fnum:
        return {'fpc': self.fpc}

    elif self.op == cot_str:
        return {'string': self.string}

    elif self.op == cot_obj:
        return {'obj_ea': self.obj_ea}

    elif self.op == cot_var:
        return {'v': self.v}

    elif self.op == cot_helper:
        return {'helper': self.helper}

    raise RuntimeError('unknown op type %s' % self.opname)
cexpr_t.operands = property(cexpr_operands)

def cinsn_details(self):
    """
     return the details pointer for the cinsn_t object depending on the value of its op member. \
        this is one of the cblock_t, cif_t, etc. objects. 
"""

    if self.op not in self.op_to_typename:
        raise RuntimeError('unknown item->op type')

    opname = self.opname
    if opname == 'empty':
        return self

    if opname in ['break', 'continue']:
        return None

    return getattr(self, 'c' + opname)
cinsn_t.details = property(cinsn_details)

def cblock_iter(self):

    iter = self.begin()
    for i in range(self.size()):
        yield iter.cur
        iter.next()

    return
cblock_t.__iter__ = cblock_iter
cblock_t.__len__ = cblock_t.size

# cblock.find(cinsn_t) -> returns the iterator positioned at the given item
def cblock_find(self, item):

    iter = self.begin()
    for i in range(self.size()):
        if iter.cur == item:
            return iter
        iter.next()

    return
cblock_t.find = cblock_find

# cblock.index(cinsn_t) -> returns the index of the given item
def cblock_index(self, item):

    iter = self.begin()
    for i in range(self.size()):
        if iter.cur == item:
            return i
        iter.next()

    return
cblock_t.index = cblock_index

# cblock.at(int) -> returns the item at the given index index
def cblock_at(self, index):

    iter = self.begin()
    for i in range(self.size()):
        if i == index:
            return iter.cur
        iter.next()

    return
cblock_t.at = cblock_at

# cblock.remove(cinsn_t)
def cblock_remove(self, item):

    iter = self.find(item)
    self.erase(iter)

    return
cblock_t.remove = cblock_remove

# cblock.insert(index, cinsn_t)
def cblock_insert(self, index, item):

    pos = self.at(index)
    iter = self.find(pos)
    self.insert(iter, item)

    return
cblock_t.insert = cblock_insert

cfuncptr_t.__str__ = lambda self: str(self.__deref__())

import ida_typeinf
def cfunc_type(self):
    """
     Get the function's return type tinfo_t object. 
    """
    tif = ida_typeinf.tinfo_t()
    result = self.get_func_type(tif)
    if not result:
        return
    return tif
cfunc_t.type = property(cfunc_type)
cfuncptr_t.type = property(lambda self: self.__deref__().type)

cfunc_t.arguments = property(lambda self: [o for o in self.lvars if o.is_arg_var])
cfuncptr_t.arguments = property(lambda self: self.__deref__().arguments)

cfunc_t.lvars = property(cfunc_t.get_lvars)
cfuncptr_t.lvars = property(lambda self: self.__deref__().lvars)
cfunc_t.warnings = property(cfunc_t.get_warnings)
cfuncptr_t.warnings = property(lambda self: self.__deref__().warnings)
cfunc_t.pseudocode = property(cfunc_t.get_pseudocode)
cfuncptr_t.pseudocode = property(lambda self: self.__deref__().get_pseudocode())
cfunc_t.eamap = property(cfunc_t.get_eamap)
cfuncptr_t.eamap = property(lambda self: self.__deref__().get_eamap())
cfunc_t.boundaries = property(cfunc_t.get_boundaries)
cfuncptr_t.boundaries = property(lambda self: self.__deref__().get_boundaries())

#pragma SWIG nowarn=+503

lvar_t.used = property(lvar_t.used)
lvar_t.typed = property(lvar_t.typed)
lvar_t.mreg_done = property(lvar_t.mreg_done)
lvar_t.has_nice_name = property(lvar_t.has_nice_name)
lvar_t.is_unknown_width = property(lvar_t.is_unknown_width)
lvar_t.has_user_info = property(lvar_t.has_user_info)
lvar_t.has_user_name = property(lvar_t.has_user_name)
lvar_t.has_user_type = property(lvar_t.has_user_type)
lvar_t.is_result_var = property(lvar_t.is_result_var)
lvar_t.is_arg_var = property(lvar_t.is_arg_var)
lvar_t.is_fake_var = property(lvar_t.is_fake_var)
lvar_t.is_overlapped_var = property(lvar_t.is_overlapped_var)
lvar_t.is_floating_var = property(lvar_t.is_floating_var)
lvar_t.is_spoiled_var = property(lvar_t.is_spoiled_var)
lvar_t.is_mapdst_var = property(lvar_t.is_mapdst_var)

# dictify all dict-like types
def _map_as_dict(maptype, name, keytype, valuetype):

    maptype.keytype = keytype
    maptype.valuetype = valuetype

    for fctname in ['begin', 'end', 'first', 'second', 'next', \
                        'find', 'insert', 'erase', 'clear', 'size']:
        fct = getattr(_ida_hexrays, name + '_' + fctname)
        setattr(maptype, '__' + fctname, fct)

    maptype.__len__ = maptype.size
    maptype.__getitem__ = maptype.at

    maptype.begin = lambda self, *args: self.__begin(self, *args)
    maptype.end = lambda self, *args: self.__end(self, *args)
    maptype.first = lambda self, *args: self.__first(*args)
    maptype.second = lambda self, *args: self.__second(*args)
    maptype.next = lambda self, *args: self.__next(*args)
    maptype.find = lambda self, *args: self.__find(self, *args)
    maptype.insert = lambda self, *args: self.__insert(self, *args)
    maptype.erase = lambda self, *args: self.__erase(self, *args)
    maptype.clear = lambda self, *args: self.__clear(self, *args)
    maptype.size = lambda self, *args: self.__size(self, *args)

    def _map___iter__(self):
        """
         Iterate over dictionary keys. 
        """
        return self.iterkeys()
    maptype.__iter__ = _map___iter__

    def _map___getitem__(self, key):
        """
         Returns the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of key should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key not in self:
            raise KeyError('key not found')
        return self.second(self.find(key))
    maptype.__getitem__ = _map___getitem__

    def _map___setitem__(self, key, value):
        """
         Returns the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if not isinstance(value, self.valuetype):
            raise KeyError('type of `value` should be ' + repr(self.valuetype) + ' but got ' + type(value))
        self.insert(key, value)
        return
    maptype.__setitem__ = _map___setitem__

    def _map___delitem__(self, key):
        """
         Removes the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key not in self:
            raise KeyError('key not found')
        self.erase(self.find(key))
        return
    maptype.__delitem__ = _map___delitem__

    def _map___contains__(self, key):
        """
         Returns true if the specified key exists in the . 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if self.find(key) != self.end():
            return True
        return False
    maptype.__contains__ = _map___contains__

    def _map_clear(self):
        self.clear()
        return
    maptype.clear = _map_clear

    def _map_copy(self):
        ret = {}
        for k in self.iterkeys():
            ret[k] = self[k]
        return ret
    maptype.copy = _map_copy

    def _map_get(self, key, default=None):
        if key in self:
            return self[key]
        return default
    maptype.get = _map_get

    def _map_iterkeys(self):
        iter = self.begin()
        while iter != self.end():
            yield self.first(iter)
            iter = self.next(iter)
        return
    maptype.iterkeys = _map_iterkeys

    def _map_itervalues(self):
        iter = self.begin()
        while iter != self.end():
            yield self.second(iter)
            iter = self.next(iter)
        return
    maptype.itervalues = _map_itervalues

    def _map_iteritems(self):
        iter = self.begin()
        while iter != self.end():
            yield (self.first(iter), self.second(iter))
            iter = self.next(iter)
        return
    maptype.iteritems = _map_iteritems

    def _map_keys(self):
        return list(self.iterkeys())
    maptype.keys = _map_keys

    def _map_values(self):
        return list(self.itervalues())
    maptype.values = _map_values

    def _map_items(self):
        return list(self.iteritems())
    maptype.items = _map_items

    def _map_has_key(self, key):
        return key in self
    maptype.has_key = _map_has_key

    def _map_pop(self, key):
        """
         Sets the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key not in self:
            raise KeyError('key not found')
        ret = self[key]
        del self[key]
        return ret
    maptype.pop = _map_pop

    def _map_popitem(self):
        """
         Sets the value associated with the provided key. 
        """
        if len(self) == 0:
            raise KeyError('key not found')
        key = self.keys()[0]
        return (key, self.pop(key))
    maptype.popitem = _map_popitem

    def _map_setdefault(self, key, default=None):
        """
         Sets the value associated with the provided key. 
        """
        if not isinstance(key, self.keytype):
            raise KeyError('type of `key` should be ' + repr(self.keytype) + ' but got ' + repr(type(key)))
        if key in self:
            return self[key]
        self[key] = default
        return default
    maptype.setdefault = _map_setdefault

#_map_as_dict(user_labels_t, 'user_labels', (int, long), qstring)
_map_as_dict(user_cmts_t, 'user_cmts', treeloc_t, citem_cmt_t)
_map_as_dict(user_numforms_t, 'user_numforms', operand_locator_t, number_format_t)
_map_as_dict(user_iflags_t, 'user_iflags', citem_locator_t, int)
import ida_pro
_map_as_dict(user_unions_t, 'user_unions', (int, long), ida_pro.intvec_t)
_map_as_dict(eamap_t, 'eamap', long, cinsnptrvec_t)
import ida_range
_map_as_dict(boundaries_t, 'boundaries', cinsn_t, ida_range.rangeset_t)

#
# Object ownership
#
def _call_with_transferrable_ownership(fun, *args):
    e = args[0]
    was_owned = e.thisown
    res = fun(e, *args[1:])
    # ATM, 'res' doesn't own the resulting cexpr_t.
    # In case 'fun'
    #   - created a new object: we want to own that one in case 'e' was owned
    #   - didn't create a new object: we will remove & re-gain ownership on
    #                                 the same underlying cexpr_t. No biggie.
    if was_owned:
        if res:
            e._maybe_disown_and_deregister()
            res._own_and_register()
    else:
        debug_hexrays_ctree("NOTE: call_with_transferrable_ownership() called with non-IDAPython-owned object. Is this intentional?")
    return res

def lnot(e):
    return _call_with_transferrable_ownership(_ll_lnot, e)

def make_ref(e):
    return _call_with_transferrable_ownership(_ll_make_ref, e)

def dereference(e, ptrsize, is_float=False):
    return _call_with_transferrable_ownership(_ll_dereference, e, ptrsize, is_float)

def call_helper(rettype, args, *rest):
    res = _ll_call_helper(rettype, args, *rest)
    if res:
        res._own_and_register()
        if type(args) == carglist_t:
            args.thisown = False
    return res

def new_block():
    res = _ll_new_block()
    if res:
        res._own_and_register()
    return res

def make_num(*args):
    res = _ll_make_num(*args)
    if res:
        res._own_and_register()
    return res

def create_helper(*args):
    res = _ll_create_helper(*args)
    if res:
        res._own_and_register()
    return res

# ----------------

class __cbhooks_t(Hexrays_Hooks):

    instances = []

    def __init__(self, callback):
        self.callback = callback
        self.instances.append(self)
        Hexrays_Hooks.__init__(self)

    def maturity(self, *args): return self.callback(hxe_maturity, *args)
    def interr(self, *args): return self.callback(hxe_interr, **args)
    def print_func(self, *args): return self.callback(hxe_print_func, *args)
    def func_printed(self, *args): return self.callback(hxe_func_printed, *args)
    def open_pseudocode(self, *args): return self.callback(hxe_open_pseudocode, *args)
    def switch_pseudocode(self, *args): return self.callback(hxe_switch_pseudocode, *args)
    def refresh_pseudocode(self, *args): return self.callback(hxe_refresh_pseudocode, *args)
    def close_pseudocode(self, *args): return self.callback(hxe_close_pseudocode, *args)
    def keyboard(self, *args): return self.callback(hxe_keyboard, *args)
    def right_click(self, *args): return self.callback(hxe_right_click, *args)
    def double_click(self, *args): return self.callback(hxe_double_click, *args)
    def curpos(self, *args): return self.callback(hxe_curpos, *args)
    def create_hint(self, *args): return self.callback(hxe_create_hint, *args)
    def text_ready(self, *args): return self.callback(hxe_text_ready, *args)
    def populating_popup(self, *args): return self.callback(hxe_populating_popup, *args)


def install_hexrays_callback(callback):
    "Deprecated. Please use Hexrays_Hooks instead"
    h = __cbhooks_t(callback)
    h.hook()
    return True

def remove_hexrays_callback(callback):
    "Deprecated. Please use Hexrays_Hooks instead"
    for inst in __cbhooks_t.instances:
        if inst.callback == callback:
            inst.unhook()
            __cbhooks_t.instances.remove(inst)
            return 1
    return 0

#</pycode(py_hexrays)>

if _BC695:
    get_tform_vdui=get_widget_vdui
    hx_get_tform_vdui=hx_get_widget_vdui
    HEXRAYS_API_MAGIC1=(HEXRAYS_API_MAGIC>>32)
    HEXRAYS_API_MAGIC2=(HEXRAYS_API_MAGIC&0xFFFFFFFFL)



